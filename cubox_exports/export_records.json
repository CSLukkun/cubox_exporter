{
  "total_items": 3,
  "successful_exports": 3,
  "exports": [
    {
      "id": "7271464141078924388",
      "title": "Python 套件管理器——Poetry 完全入門指南 - Code and Me",
      "data": {
        "content_type": "application/zip;charset=UTF-8",
        "content": "<html id=\"html-top\" lang=\"zh\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>Python 套件管理器——Poetry 完全入門指南</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n  <link rel=\"icon\" href=\"https://cubox.pro/my/favicon.svg\" type=\"image/x-icon\">\n  <link href=\"https://cubox.pro/article/css/reader.css\" rel=\"stylesheet\">\n </head>\n <body ontouchstart>\n  <div class=\"reader-page\">\n   <div>\n    <h1 class=\"reader-title\">Python 套件管理器——Poetry 完全入門指南</h1>\n    <div class=\"reader-metadata\">\n     <a href=\"https://blog.kyomind.tw/python-poetry/\" target=\"_blank\">blog.kyomind.tw</a><span class=\"reader-metadata-author\">Kyo Huang</span>\n    </div>\n    <div> \n     <p><a title=\"by Feifei Ruan on Behance\" href=\"https://i.imgur.com/3QW32TX.jpg\" target=\"_blank\"><img data-cubox-image-src=\"https://i.imgur.com/3QW32TX.jpg\" data-cubox-image-load=\"false\" data-cubox-image-index=\"0\" data-cubox-image- src=\"https://image.cubox.pro/cardImg/58ott3xhvspgxxnydagzxsz8f8q1z0z6ptdk6efnixlbtx8p0n.jpg?imageMogr2/quality/90/ignore-error/1\" origin-src=\"https://i.imgur.com/3QW32TX.jpg\" loading=\"lazy\"></a><span data-relin-paragraph=\"29\" data-relingo-block=\"true\">by Feifei Ruan on Behance</span></p> \n     <blockquote> \n      <p data-relin-paragraph=\"30\" data-relingo-block=\"true\"><code>2024/06/17</code>：縮減本文篇幅，方便讀者回顧，將「<a href=\"https://blog.kyomind.tw/python-poetry/#pip-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E9%81%B8%E6%93%87%E2%80%94%E2%80%94Pipenv-vs-Poetry\" target=\"_blank\">pip 替代方案選擇——Pipenv vs Poetry</a>」相關部分移至 <a href=\"https://kyomind.notion.site/pip-Pipenv-vs-Poetry-87c97bfba71340efa58d65ce22e71b97\" rel=\"noopener\" target=\"_blank\">Notion 頁面</a>。<br><code>2024/03/13</code>：補充<span>範例 repository</span> 作為具體參考。<br><code>2024/01/09</code>：重新修訂「<span>名詞解釋</span>」章節。具體說明 <strong>Poetry 解決的兩大痛點</strong>。<br><code>2024/01/05</code>：新增「<span>指定套件版本範圍</span>」章節。<br><code>2023/12/30</code>：重新修訂「<span>安裝 Poetry</span>」章節。</p> \n     </blockquote> \n     <blockquote> \n      <p data-relin-paragraph=\"31\" data-relingo-block=\"true\">相關文章：<a href=\"https://blog.kyomind.tw/linux-dev-setup/\" target=\"_blank\">Python 開發環境設定：zsh、zinit、pyenv、Poetry、Docker</a></p> \n     </blockquote> \n     <p data-relin-paragraph=\"32\" data-relingo-block=\"true\">前陣子工作上的專案從原先的 pip 改用 Poetry 管理 Python 套件，由於採用 Poetry 正是我的提議，所以得身先士卒，研究 Poetry 使用上的重點與學習成本，並評估是否真有所值——講白了就是至少要利大於弊，不然會徒增團隊適應上的負擔。</p> \n     <p data-relin-paragraph=\"33\" data-relingo-block=\"true\">拜這個機會所賜，我對 Poetry 總算有了一個較為全面的理解。</p> \n     <p data-relin-paragraph=\"34\" data-relingo-block=\"true\">習慣後，現在我所有的個人開發也都改用 Poetry 來管理套件及虛擬環境，對於 Poetry 這個略嫌複雜的工具（相較 pip），上手的同時我也感受到它確實存在一些<strong>學習門檻</strong>，間接促使了本文的誕生。</p> \n     <h3 data-relin-paragraph=\"35\" data-relingo-block=\"true\"><span title=\"系列：Python Poetry 三部曲\"></span>系列：Python Poetry 三部曲</h3> \n     <blockquote> \n      <ol> \n       <li data-relin-paragraph=\"36\" data-relingo-block=\"true\"><strong>Python 套件管理器——Poetry 完全入門指南</strong></li> \n       <li data-relin-paragraph=\"37\" data-relingo-block=\"true\"><a href=\"https://blog.kyomind.tw/poetry-pyenv-practical-tips/\" target=\"_blank\">Poetry + pyenv 教學：常用指令與注意事項</a></li> \n       <li data-relin-paragraph=\"38\" data-relingo-block=\"true\">Docker 教學：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）</li> \n      </ol> \n     </blockquote> \n     <h3 data-relin-paragraph=\"39\" data-relingo-block=\"true\"><span title=\"本文定位：獻給 Poetry 新手的使用說明書\"></span>本文定位：獻給 Poetry 新手的使用說明書</h3> \n     <p data-relin-paragraph=\"40\" data-relingo-block=\"true\">有鑑於 Poetry 真的有點複雜，如果要推薦別人使用，我想還是有必要好好介紹一下。換句話說，這會是一篇<strong>完整的入門教學</strong>。</p> \n     <p data-relin-paragraph=\"41\" data-relingo-block=\"true\">本文除了講解如何使用 Poetry，還會先<strong>不厭其煩地闡述它所解決的痛點</strong>，如果對此興趣有限，可以直接跳到「<span>從零開始使用 Poetry</span>」章節，但看完前導部分，相信能更加體會 Poetry 的<strong>必要性與強大</strong>之處。</p> \n     <p data-relin-paragraph=\"42\" data-relingo-block=\"true\">為了讓你<strong>無痛上手</strong>，這將會是一篇超過 8000 字的長文，還請多多擔待。🙏</p> \n     <h3 data-relin-paragraph=\"43\" data-relingo-block=\"true\"><span title=\"範例 repository\"></span>範例 repository</h3> \n     <p data-relin-paragraph=\"44\" data-relingo-block=\"true\">想要善用 Poetry，除了必須了解 Poetry 指令，熟悉<code>pyproject.toml</code>檔案的設定也很重要。</p> \n     <p data-relin-paragraph=\"45\" data-relingo-block=\"true\">有關 Poetry 的<code>pyproject.toml</code>具體內容，可以參考這個範例專案：<a href=\"https://github.com/kyomind/Django-Tutorial\" rel=\"noopener\" target=\"_blank\">Django-Tutorial</a> 中的<code>pyproject.toml</code>；或直接前往<a href=\"https://github.com/kyomind/Django-Tutorial/blob/main/pyproject.toml\" rel=\"noopener\" target=\"_blank\">檔案網址</a>。</p> \n     <h3 data-relin-paragraph=\"46\" data-relingo-block=\"true\"><span title=\"本文目錄\"></span>本文目錄</h3> \n     <p data-relin-paragraph=\"47\" data-relingo-block=\"true\">方便快速跳轉到有興趣的部分，桌面版用戶可和右下角的「回到最上方」搭配使用：</p> \n     <ol> \n      <li data-relin-paragraph=\"48\" data-relingo-block=\"true\"><span>Poetry 是什麼？</span></li> \n      <li data-relin-paragraph=\"49\" data-relingo-block=\"true\"><span>名詞解釋</span></li> \n      <li data-relin-paragraph=\"50\" data-relingo-block=\"true\"><span>pip 的最大不足</span></li> \n      <li data-relin-paragraph=\"51\" data-relingo-block=\"true\"><span>安裝 Poetry</span></li> \n      <li data-relin-paragraph=\"52\" data-relingo-block=\"true\"><span>設定 PATH 環境變數</span></li> \n      <li data-relin-paragraph=\"53\" data-relingo-block=\"true\"><span>初始化 Poetry</span></li> \n      <li data-relin-paragraph=\"54\" data-relingo-block=\"true\"><span>管理 Poetry 虛擬環境</span></li> \n      <li data-relin-paragraph=\"55\" data-relingo-block=\"true\"><span>修改 config，建立專案內 .venv 虛擬環境</span></li> \n      <li data-relin-paragraph=\"56\" data-relingo-block=\"true\"><span>Poetry 新增套件</span></li> \n      <li data-relin-paragraph=\"57\" data-relingo-block=\"true\"><span>指定套件「版本」範圍</span></li> \n      <li data-relin-paragraph=\"58\" data-relingo-block=\"true\"><span>新增套件至 dev-dependencies</span></li> \n      <li data-relin-paragraph=\"59\" data-relingo-block=\"true\"><span>Poetry 更新套件</span></li> \n      <li data-relin-paragraph=\"60\" data-relingo-block=\"true\"><span>列出全部套件清單</span></li> \n      <li data-relin-paragraph=\"61\" data-relingo-block=\"true\"><span>Poetry 移除套件</span></li> \n      <li data-relin-paragraph=\"62\" data-relingo-block=\"true\"><span>輸出 Poetry 虛擬環境的 requirements.txt</span></li> \n      <li data-relin-paragraph=\"63\" data-relingo-block=\"true\"><span>Poetry 常用指令清單</span></li> \n      <li data-relin-paragraph=\"64\" data-relingo-block=\"true\"><span>Poetry 常見使用情境與操作 QA</span></li> \n      <li data-relin-paragraph=\"65\" data-relingo-block=\"true\"><span>結語：井然有序的複雜</span></li> \n     </ol> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"66\" data-relingo-block=\"true\"><span title=\"Poetry 是什麼？\"></span>Poetry 是什麼？</h2> \n     <p data-relin-paragraph=\"67\" data-relingo-block=\"true\">要了解 Poetry 大致的作用與功能，參考 <a href=\"https://github.com/python-poetry/poetry#poetry-dependency-management-for-python\" rel=\"noopener\" target=\"_blank\">Poetry GitHub</a> 說明是一個不錯的開始：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"68\" data-relingo-block=\"true\"><strong>Poetry: Dependency Management for Python</strong><br>Poetry helps you declare, manage and install dependencies of Python projects</p> \n     </blockquote> \n     <p data-relin-paragraph=\"69\" data-relingo-block=\"true\">而 <a href=\"https://python-poetry.org/\" rel=\"noopener\" target=\"_blank\">Poetry 官網</a>的 slogan 則更加簡潔有力：</p> \n     <p><a title=\"python-poetry.org\" href=\"https://i.imgur.com/xnYx0FB.png\" target=\"_blank\"><img data-cubox-image-src=\"https://i.imgur.com/xnYx0FB.png\" data-cubox-image-load=\"false\" data-cubox-image-index=\"1\" data-cubox-image- src=\"https://image.cubox.pro/cardImg/vwy3bh3jwfpek82yo7pqdt9xlow1rtervgz724pec71a1tltn.png?imageMogr2/quality/90/ignore-error/1\" origin-src=\"https://i.imgur.com/xnYx0FB.png\" loading=\"lazy\"></a><span data-relin-paragraph=\"70\" data-relingo-block=\"true\">python-poetry.org</span></p> \n     <p data-relin-paragraph=\"71\" data-relingo-block=\"true\">簡單來說，<strong>Poetry 類似 pip，能協助你進行套件管理（dependency management），但又比 pip 強大得多，因為它還包含了 pip 所未有的下列功能：</strong></p> \n     <ul> \n      <li data-relin-paragraph=\"72\" data-relingo-block=\"true\">虛擬環境管理</li> \n      <li data-relin-paragraph=\"73\" data-relingo-block=\"true\">套件相依性管理</li> \n      <li data-relin-paragraph=\"74\" data-relingo-block=\"true\">套件的打包與發布</li> \n     </ul> \n     <p data-relin-paragraph=\"75\" data-relingo-block=\"true\">其中<strong>最為關鍵</strong>的是「<strong>套件的相依性管理</strong>」，也是本文的重點，而「套件的打包與發布」與本文主題無關，所以不會提及。</p> \n     <h2 data-relin-paragraph=\"76\" data-relingo-block=\"true\"><span title=\"名詞解釋\"></span>名詞解釋</h2> \n     <p data-relin-paragraph=\"77\" data-relingo-block=\"true\">開始前，要先大致說明下列三者的區別，才不易混淆文中的內容。這裡的定義可能不盡準確，但至少對理解文中的表達能有所幫助。</p> \n     <h3 data-relin-paragraph=\"78\" data-relingo-block=\"true\"><span title=\"虛擬環境管理\"></span>虛擬環境管理</h3> \n     <p data-relin-paragraph=\"79\" data-relingo-block=\"true\">指的是使用內建的 venv 或 virtualenv 套件來建立及管理 Python 的虛擬環境，不同的虛擬環境間各自獨立，也就是<strong>對應的路徑</strong>各不相同。</p> \n     <h3 data-relin-paragraph=\"80\" data-relingo-block=\"true\"><span title=\"套件管理（dependency management）\"></span>套件管理（dependency management）</h3> \n     <p data-relin-paragraph=\"81\" data-relingo-block=\"true\">指的是使用 pip 這類的套件管理器來管理 Python 環境（未必是虛擬環境），即管理環境中所安裝的全部套件（package、dependency）及其版本。</p> \n     <p data-relin-paragraph=\"82\" data-relingo-block=\"true\">在這個<strong>語境</strong>下，<strong>dependency</strong> 基本上就是你安裝的<strong>套件（package）</strong>。</p> \n     <h3 data-relin-paragraph=\"83\" data-relingo-block=\"true\"><span title=\"套件的「相依性管理」（重要）\"></span>套件的「相依性管理」（重要）</h3> \n     <p data-relin-paragraph=\"84\" data-relingo-block=\"true\">這個有點難定義，因為它不是一個很有共識的名詞，我在英文中也難找到對應的單字。這裡指<strong>管理套件之間的「依賴關係」及「版本衝突」這兩件事</strong>：</p> \n     <ol> \n      <li data-relin-paragraph=\"85\" data-relingo-block=\"true\"><strong>依賴關係</strong>指的是，當一個套件被安裝時，它所依賴的套件也必須<strong>一併安裝</strong>（這個很簡單）。反之，當一個套件被移除時，它所依賴的套件也必須<strong>一併移除——除非這些套件還被其他套件所依賴（這個就比較複雜了）。</strong></li> \n      <li data-relin-paragraph=\"86\" data-relingo-block=\"true\">而<strong>版本衝突</strong>，指的是單一套件被兩個以上的套件所依賴，但不同的套件對依賴的套件有著不同的<strong>最低或最高版本要求</strong>，若兩者要求的範圍「<strong>沒有交集</strong>」，則會發生衝突而導致套件<strong>失效</strong>或<strong>無法安裝</strong>。</li> \n     </ol> \n     <p data-relin-paragraph=\"87\" data-relingo-block=\"true\">這兩大問題，都是 pip 所無法解決的，也是 Python 開發上的<strong>兩大痛點</strong>。</p> \n     <p data-relin-paragraph=\"88\" data-relingo-block=\"true\"><strong>而 Poetry 就是為了解決它們而生。</strong></p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"89\" data-relingo-block=\"true\"><span title=\"pip 的最大不足\"></span>pip 的最大不足</h2> \n     <p data-relin-paragraph=\"90\" data-relingo-block=\"true\">大概在 2 年前就聽過 Poetry 的大名，不過那時我還沒有套件相依性管理的強烈需求，加上看起來需要一些學習成本（確實如此），所以就一直擱在一旁，直到真正體會到了 pip 的不足。</p> \n     <p data-relin-paragraph=\"91\" data-relingo-block=\"true\">pip 是 Python 內建的套件管理工具，而它的最大罩門，就是對於「套件間的相依性管理」能力不足。尤其是在「<strong>移除</strong>」套件時的依賴解析——可以說沒有。這也是我提議改用 Poetry 的根本原因。</p> \n     <p data-relin-paragraph=\"92\" data-relingo-block=\"true\">怎麼說？看完下面的例子就能明白。</p> \n     <h3 data-relin-paragraph=\"93\" data-relingo-block=\"true\"><span title=\"pip uninstall的困境：以 Flask 為例\"></span><code>pip uninstall</code>的困境：以 Flask 為例</h3> \n     <p data-relin-paragraph=\"94\" data-relingo-block=\"true\">假設現在你的工作專案中有開發 API 的需求，經過一番研究與討論，決定使用 <a href=\"https://github.com/pallets/flask\" rel=\"noopener\" target=\"_blank\">Flask</a> 網頁框架來進行開發。</p> \n     <p data-relin-paragraph=\"95\" data-relingo-block=\"true\">我們知道，很多套件都有依賴的套件，也就是使用「別人已經造好的輪子」來構成套件功能的一部分。</p> \n     <p data-relin-paragraph=\"96\" data-relingo-block=\"true\">安裝主套件時，這些依賴套件也<strong>必須一併安裝，主套件才能正常運作</strong>，這裡的 Flask 就是如此。安裝 Flask 時，不會只安裝單一個<code>flask</code>套件，還會安裝所有 Flask 的必要構成部分——也就是依賴套件，結果如下：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></pre></td> \n         <td><pre><span>❯ pip install flask</span><br><span>Collecting flask</span><br><span>  Downloading Flask-2.1.1-py3-none-any.whl (95 kB)</span><br><span>     |████████████████████████████████| 95 kB 993 kB/s</span><br><span>...</span><br><span>Installing collected packages: zipp, MarkupSafe, Werkzeug, Jinja2, itsdangerous, importlib-metadata, click, flask</span><br><span>Successfully installed Jinja2-3.1.1 MarkupSafe-2.1.1 Werkzeug-2.1.1 click-8.1.2 flask-2.1.1 importlib-metadata-4.11.3 itsdangerous-2.1.2 zipp-3.7.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"97\" data-relingo-block=\"true\">從上可知，<code>pip install flask</code>還會一併安裝<code>importlib-metadata</code>、<code>itsdangerous</code>等 7 個依賴套件，實際上總共安裝了 8 個套件！</p> \n     <p data-relin-paragraph=\"98\" data-relingo-block=\"true\">可以說，pip 在「安裝」套件時的相依性管理還是可以的，這並不難，因為套件的依賴要求都寫在安裝檔裡了，根本不需要「管理」。</p> \n     <hr data-relingo-block=\"true\"> \n     <p data-relin-paragraph=\"99\" data-relingo-block=\"true\">附帶一提，這 8 個套件包括<code>flask</code>，除了<code>importlib-metadata</code>和<code>zipp</code>外，其餘 6 個實際上都是由 <a href=\"https://palletsprojects.com/p/\" rel=\"noopener\" target=\"_blank\">Flask 團隊自行開發</a>。</p> \n     <p data-relin-paragraph=\"100\" data-relingo-block=\"true\"><strong>但並非只有 Flask 框架會使用（依賴）這些套件。</strong></p> \n     <p data-relin-paragraph=\"101\" data-relingo-block=\"true\">比如其中的 <a href=\"https://palletsprojects.com/p/click/\" rel=\"noopener\" target=\"_blank\">Click</a> 就是一個<strong>被廣泛使用的命令列製作工具</strong>。套件官網是這麼介紹的：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"102\" data-relingo-block=\"true\">Click is a Python package for <strong>creating beautiful command line interfaces</strong> in a composable way with as little code as necessary.</p> \n     </blockquote> \n     <p data-relin-paragraph=\"103\" data-relingo-block=\"true\">別的套件也可能依賴<code>click</code>來提供命令列的功能，換句話說，主套件的依賴套件也可能被其他第三方套件所依賴、使用。<strong>這就產生了「衝突」的可能。</strong></p> \n     <hr data-relingo-block=\"true\"> \n     <p data-relin-paragraph=\"104\" data-relingo-block=\"true\">好，一切都很美好，就這樣一年過去，團隊決定改用火紅的 FastAPI 取代 Flask 來實作專案的 API，作為 API 的主要開發人員，你對新技術充滿了期待（或排斥），興高采列地安裝了 FastAPI，更新了所有程式碼，最後要移除 Flask，這時問題就來了。</p> \n     <p data-relin-paragraph=\"105\" data-relingo-block=\"true\">安裝 Flask 的時候，我們只需要<code>pip install flask</code>，pip 就會幫你一併安裝所有依賴套件。現在要移除它，也只要<code>pip uninstall flask</code>就可以了嗎？</p> \n     <blockquote> \n      <p data-relin-paragraph=\"106\" data-relingo-block=\"true\"><strong>很遺憾，答案是否定的</strong>。</p> \n     </blockquote> \n     <h3 data-relin-paragraph=\"107\" data-relingo-block=\"true\"><span title=\"pip 的致命缺陷：缺乏移除套件時的相依性管理\"></span>pip 的致命缺陷：缺乏移除套件時的相依性管理</h3> \n     <p data-relin-paragraph=\"108\" data-relingo-block=\"true\">僅執行<code>pip uninstall flask</code>的話，pip 就<strong>真的只會</strong>幫你移除<code>flask</code>這個套件<strong>本身</strong>而已。那剩下的、再也用不到的套件怎麼辦？你只能一個一個手動移除！</p> \n     <p data-relin-paragraph=\"109\" data-relingo-block=\"true\">但你千萬不要真的嘗試手動移除依賴套件！——因為你無法確定這些依賴套件<strong>是否同時被別的套件所依賴</strong>。</p> \n     <p data-relin-paragraph=\"110\" data-relingo-block=\"true\">也就是 pip 做不到上面「<span>套件的相依性管理</span>」中的<strong>第一點</strong>：<strong>移除套件時的相依性管理</strong>。（其實第二點也做不到，但這裡先不談）</p> \n     <h3 data-relin-paragraph=\"111\" data-relingo-block=\"true\"><span title=\"pip 手動移除依賴套件的潛在風險：以 Flask + Black 為例\"></span>pip 手動移除依賴套件的潛在風險：以 Flask + Black 為例</h3> \n     <p data-relin-paragraph=\"112\" data-relingo-block=\"true\">繼續以 Flask 為例，還記得其中一個依賴套件是<code>click</code>，如前所述，它是一個協助製作命令列界面的工具。</p> \n     <p data-relin-paragraph=\"113\" data-relingo-block=\"true\">假設專案中已同時安裝了 <a href=\"https://github.com/psf/black\" rel=\"noopener\" target=\"_blank\">Black</a> 這個 formatter，Black 是一個可以透過 CLI 指令執行的格式化工具，<strong>剛好，它也是使用<code>click</code>來實作命令列功能。</strong></p> \n     <blockquote> \n      <p data-relin-paragraph=\"114\" data-relingo-block=\"true\"><strong>Black Formatter</strong> 相關文章：</p> \n      <ul> \n       <li data-relin-paragraph=\"115\" data-relingo-block=\"true\"><a href=\"https://blog.kyomind.tw/black-and-isort/\" target=\"_blank\">試用從 Python extension 拆分的 Black、isort 套件</a></li> \n       <li data-relin-paragraph=\"116\" data-relingo-block=\"true\"><a href=\"https://blog.kyomind.tw/flake8-and-black/\" target=\"_blank\">Python Flake8 與 Black Formatter 擴充套件快速上手</a></li> \n      </ul> \n     </blockquote> \n     <p data-relin-paragraph=\"117\" data-relingo-block=\"true\">我們可以藉由 Poetry 指令來查看，目前這兩個套件的<strong>依賴關係狀態</strong>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></pre></td> \n         <td><pre><span>black 22.3.0 The uncompromising code formatter.</span><br><span>├── click &gt;=8.0.0</span><br><span>│   └── colorama *</span><br><span>├── mypy-extensions &gt;=0.4.3</span><br><span>├── pathspec &gt;=0.9.0</span><br><span>├── platformdirs &gt;=2</span><br><span>├── tomli &gt;=1.1.0</span><br><span>└── typing-extensions &gt;=3.10.0.0</span><br><span>flask 2.1.2 A simple framework <span>for</span> building complex web applications.</span><br><span>├── click &gt;=8.0</span><br><span>│   └── colorama *</span><br><span>├── importlib-metadata &gt;=3.6.0</span><br><span>│   └── zipp &gt;=0.5</span><br><span>├── itsdangerous &gt;=2.0</span><br><span>├── jinja2 &gt;=3.0</span><br><span>│   └── markupsafe &gt;=2.0</span><br><span>└── werkzeug &gt;=2.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"118\" data-relingo-block=\"true\">可以明顯看出，<strong>兩者都依賴了<code>click</code>套件</strong>。</p> \n     <p data-relin-paragraph=\"119\" data-relingo-block=\"true\">可想而知，移除 Flask 時，如果你同時把<code>click</code>也<strong>跟著一併手動移除</strong>，會發生什麼樣的悲劇——<strong>你的 Black 壞了</strong>——因為它缺少了必要的依賴套件<code>click</code>。</p> \n     <hr data-relingo-block=\"true\"> \n     <p data-relin-paragraph=\"120\" data-relingo-block=\"true\">簡言之，直接 pip 手動移除依賴套件存在下列兩大疑慮，不建議輕易嘗試：</p> \n     <h4 data-relin-paragraph=\"121\" data-relingo-block=\"true\"><span title=\"一、不確定想移除的套件「有多少依賴套件」\"></span>一、不確定想移除的套件「有多少依賴套件」</h4> \n     <p data-relin-paragraph=\"122\" data-relingo-block=\"true\">正常而言，你不會去注意安裝時總共一併安裝了多少依賴套件。雖然有<code>pip show</code>這類的指令可以大概知曉套件的依賴，但這指令只會顯示「<strong>直接</strong>依賴套件」而不會顯示「依賴套件的依賴」，所以列出來的結果未必準確：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></pre></td> \n         <td><pre><span>❯ pip show flask</span><br><span>Name: Flask</span><br><span>Version: 2.1.1</span><br><span>Summary: A simple framework <span>for</span> building complex web applications.</span><br><span>Home-page: https://palletsprojects.com/p/flask</span><br><span>Author: Armin Ronacher</span><br><span>Author-email: armin.ronacher@active-4.com</span><br><span>License: BSD-3-Clause</span><br><span>Location: /Users/kyo/.pyenv/versions/3.8.12/envs/test/lib/python3.8/site-packages</span><br><span>Requires: importlib-metadata, Werkzeug, click, Jinja2, itsdangerous</span><br><span>Required-by:</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"123\" data-relingo-block=\"true\">可以看到，<code>Requires:</code>只顯示了 5 個依賴套件，因為剩下的 2 個（<code>zipp</code>、<code>markupsafe</code>）是「<strong>依賴的依賴</strong>」，在更下層，並未顯示。</p> \n     <h4 data-relin-paragraph=\"124\" data-relingo-block=\"true\"><span title=\"二、即使確定依賴套件，也無法確定這些套件「是否還被其他套件所依賴」\"></span>二、即使確定依賴套件，也無法確定這些套件「是否還被其他套件所依賴」</h4> \n     <p data-relin-paragraph=\"125\" data-relingo-block=\"true\">好繞口啊！上述的<code>click</code>例子就是解釋這個困境。</p> \n     <h3 data-relin-paragraph=\"126\" data-relingo-block=\"true\"><span title=\"小結：pip 只適合小型專案或「只新增不移除」套件的專案\"></span>小結：pip 只適合小型專案或「只新增不移除」套件的專案</h3> \n     <p data-relin-paragraph=\"127\" data-relingo-block=\"true\">以前我的個人或工作上的專案往往規模不大，pip 就真的只負責新增，鮮少需要考慮移除套件的情況，所以缺少移除套件時的依賴解析，似乎也沒什麼大問題。</p> \n     <p data-relin-paragraph=\"128\" data-relingo-block=\"true\">但稍具模規的專案往往就需要考慮套件的退場，以維持開發及部署環境的簡潔，尤其在使用容器化部署時，<strong>過多不必要的套件會徒增 image 肥大，產生額外的成本與資源浪費不說，同時也提升了「套件之間發生衝突」的可能。</strong></p> \n     <p data-relin-paragraph=\"129\" data-relingo-block=\"true\">然而透過上述的例子可知，僅靠 pip 想要<strong>乾淨移除</strong>過時的套件，且不影響既有的套件，簡直是<strong>不可能的任務！</strong>所以我們需要擁有「<strong>完整套件相依性管理功能</strong>」的套件管理器。</p> \n     <hr data-relingo-block=\"true\"> \n     <h3 data-relin-paragraph=\"130\" data-relingo-block=\"true\"><span title=\"pip 替代方案選擇——Pipenv vs Poetry\"></span>pip 替代方案選擇——Pipenv vs Poetry</h3> \n     <p data-relin-paragraph=\"131\" data-relingo-block=\"true\">考慮內容時效性與縮減篇幅，本段及「<strong>選擇 Poetry 的兩個理由</strong>」已移至 <a href=\"https://kyomind.notion.site/pip-Pipenv-vs-Poetry-87c97bfba71340efa58d65ce22e71b97\" rel=\"noopener\" target=\"_blank\">Notion</a>。</p> \n     <h3 data-relin-paragraph=\"132\" data-relingo-block=\"true\"><span title=\"從零開始使用 Poetry\"></span>從零開始使用 Poetry</h3> \n     <p data-relin-paragraph=\"133\" data-relingo-block=\"true\">好，漫長的前言到此結束，讓我們進入正題，開始上手學習 Poetry。</p> \n     <blockquote> \n      <p data-relin-paragraph=\"134\" data-relingo-block=\"true\"><code>2023/04/08</code>：本文最初創作於 Poetry 版本 1.1.19 時期，目前最新版為 1.4.x，部分指令的參數可能略有變動（但不影響理解），請以官方文件為準。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"135\" data-relingo-block=\"true\">本文主要以 macOS 和 Linux（Ubuntu）環境來進行安裝及教學，Windows 用戶如果有無法順利安裝的情況，建議參考官方文件內容修正。</p> \n     <p data-relin-paragraph=\"136\" data-relingo-block=\"true\">不過，即使有問題，應該也是集中在安裝與設定階段，其餘部分仍可適用。</p> \n     <h2 data-relin-paragraph=\"137\" data-relingo-block=\"true\"><span title=\"安裝 Poetry\"></span>安裝 Poetry</h2> \n     <blockquote> \n      <p data-relin-paragraph=\"138\" data-relingo-block=\"true\"><code>2023/12/30</code>：之前把安裝分為「全域」和「pip 安裝」兩種，具有一定<strong>誤導性</strong>。加上官方文件後來也更新了<code>pipx</code>安裝方式，所以本段重新修訂。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"139\" data-relingo-block=\"true\">Poetry 和 pip、git、pyenv 等工具一樣，都是典型的<strong>命令列工具</strong>，需要先安裝才能下達指令——<code>poetry</code>。</p> \n     <h3 data-relin-paragraph=\"140\" data-relingo-block=\"true\"><span title=\"安裝方式選擇\"></span>安裝方式選擇</h3> \n     <p data-relin-paragraph=\"141\" data-relingo-block=\"true\">Poetry 是一個 Python 套件，需要有 Python 執行環境才能正常運行。</p> \n     <p data-relin-paragraph=\"142\" data-relingo-block=\"true\">Poetry 提供了<a href=\"https://python-poetry.org/docs/#installation\" rel=\"noopener\" target=\"_blank\">兩種主要的安裝方式</a>：</p> \n     <ol> \n      <li data-relin-paragraph=\"143\" data-relingo-block=\"true\">使用<code>pipx</code>安裝。</li> \n      <li data-relin-paragraph=\"144\" data-relingo-block=\"true\">使用 official installer（即下述的安裝指令）安裝。</li> \n     </ol> \n     <p data-relin-paragraph=\"145\" data-relingo-block=\"true\">以上兩種方式大同小異，核心內涵都是「<strong>自動為你建立一個 Python 虛擬環境，並在其中安裝 Poetry</strong>」，以達到 <strong>Poetry 安裝環境的獨立與隔離</strong>。</p> \n     <p data-relin-paragraph=\"146\" data-relingo-block=\"true\">如果你平常沒在使用 <a href=\"https://github.com/pypa/pipx\" rel=\"noopener\" target=\"_blank\">pipx</a>，那選擇第二種方式即可。</p> \n     <h3 data-relin-paragraph=\"147\" data-relingo-block=\"true\"><span title=\"避免安裝 Poetry 至專案虛擬環境\"></span>避免安裝 Poetry 至專案虛擬環境</h3> \n     <p data-relin-paragraph=\"148\" data-relingo-block=\"true\">安裝 Poetry 的時候，一定將它安裝在一個<strong>「專用」的虛擬環境</strong>。上述兩種安裝方式都滿足這個條件。</p> \n     <p data-relin-paragraph=\"149\" data-relingo-block=\"true\">千萬不要為了方便，把 Poetry 直接安裝至你的專案虛擬環境，<strong>這麼做是危險的</strong>。</p> \n     <p data-relin-paragraph=\"150\" data-relingo-block=\"true\">因為 Poetry 所依賴的套件非常多，<strong>總計超過 30 個，會嚴重影響專案虛擬環境的整潔度</strong>。這些依賴套件可能和專案本身的套件<strong>發生衝突</strong>。</p> \n     <p data-relin-paragraph=\"151\" data-relingo-block=\"true\">所以官方文件才會提醒你：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"152\" data-relingo-block=\"true\"><strong>Poetry should always be installed in a dedicated virtual environment to isolate it from the rest of your system.</strong> In no case, it should be installed in the environment of the project that is to be managed by Poetry.</p> \n     </blockquote> \n     <hr data-relingo-block=\"true\"> \n     <h3 data-relin-paragraph=\"153\" data-relingo-block=\"true\"><span title=\"使用 official installer 安裝 Poetry 至家目錄\"></span>使用 official installer 安裝 Poetry 至家目錄</h3> \n     <p data-relin-paragraph=\"154\" data-relingo-block=\"true\">我個人使用 <a href=\"https://python-poetry.org/docs/#installing-with-the-official-installer\" rel=\"noopener\" target=\"_blank\">official installer</a> 安裝。</p> \n     <p data-relin-paragraph=\"155\" data-relingo-block=\"true\">要用 official installer 安裝 Poetry，只要在命令列輸入下列指令。</p> \n     <h4 data-relin-paragraph=\"156\" data-relingo-block=\"true\"><span title=\"macOS / Linux / WSL（Windows Subsystem for Linux）\"></span>macOS / Linux / WSL（Windows Subsystem for Linux）</h4> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>curl -sSL https://install.python-poetry.org | python3 -</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <h4 data-relin-paragraph=\"157\" data-relingo-block=\"true\"><span title=\"Windows\"></span>Windows</h4> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"158\" data-relingo-block=\"true\">Poetry 實際安裝路徑如下：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"159\" data-relingo-block=\"true\">The installer installs the&nbsp;<code>poetry</code>&nbsp;tool to Poetry’s&nbsp;<code>bin</code>&nbsp;directory. This location depends on your system:</p> \n     </blockquote> \n     <ul> \n      <li data-relin-paragraph=\"160\" data-relingo-block=\"true\"><code>$HOME/.local/bin</code>&nbsp;for Unix</li> \n      <li data-relin-paragraph=\"161\" data-relingo-block=\"true\"><code>%APPDATA%\\Python\\Scripts</code>&nbsp;on Windows</li> \n     </ul> \n     <p data-relin-paragraph=\"162\" data-relingo-block=\"true\">以 macOS 為例，如果要下<code>poetry</code>指令，就需要打完整路徑<code>$HOME/.local/bin/poetry</code>，顯然不太方便，所以我們需要設定 PATH。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"163\" data-relingo-block=\"true\"><span title=\"設定 PATH 環境變數\"></span>設定 PATH 環境變數</h2> \n     <p data-relin-paragraph=\"164\" data-relingo-block=\"true\">如果你選擇<code>pipx</code>安裝 Poetry，原則上不需要設定 PATH，因為<code>pipx</code>會自動幫你設定——難怪官方把<code>pipx</code>安裝方式放在分頁的首位。</p> \n     <p data-relin-paragraph=\"165\" data-relingo-block=\"true\">如果你選擇「<strong>official installer 安裝」，那這一步非常重要</strong>，我們<strong>必須先「手動設定」PATH</strong>，否則作業系統不知道<code>poetry</code>指令的執行檔在哪，根本<strong>無法使用</strong>。</p> \n     <blockquote> \n      <p data-relin-paragraph=\"166\" data-relingo-block=\"true\">至於 PATH 是什麼，可以參考良葛格這篇〈<a href=\"https://openhome.cc/Gossip/JavaEssence/WhatPath.html\" rel=\"noopener\" target=\"_blank\">PATH 是什麼？</a>〉。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"167\" data-relingo-block=\"true\">總之，我們要將<code>poetry</code>執行檔所在的路徑（目錄）新增至 PATH。</p> \n     <h3 data-relin-paragraph=\"168\" data-relingo-block=\"true\"><span title=\"在 macOS 或 Linux 上設定 PATH\"></span>在 macOS 或 Linux 上設定 PATH</h3> \n     <p data-relin-paragraph=\"169\" data-relingo-block=\"true\">使用 macOS 或 Linux，設定 PATH 的步驟相對簡單，只要在<code>.zshrc</code>或<code>.bashrc</code>或<code>.bash_profile</code>新增：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span><span>export</span> PATH=<span>$PATH</span>:<span>$HOME</span>/.local/bin</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"170\" data-relingo-block=\"true\">存檔後重啟 shell 即可使用。直接在命令列打上<code>poetry</code>指令測試。</p> \n     <h3 data-relin-paragraph=\"171\" data-relingo-block=\"true\"><span title=\"在 Windows 上設定 PATH\"></span>在 Windows 上設定 PATH</h3> \n     <p data-relin-paragraph=\"172\" data-relingo-block=\"true\">Windows 用戶可參考 JetBrains 的 <a href=\"https://www.jetbrains.com/help/dataspell/poetry.html\" rel=\"noopener\" target=\"_blank\">Poetry 設定教學</a>。我覺得寫得比 Poetry 官方文件更好懂：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span><span>$Env</span>:Path += <span>\";C:\\Users\\jetbrains\\AppData\\Roaming\\Python\\Scripts\"</span>; setx PATH <span>\"<span>$Env</span>:Path\"</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"173\" data-relingo-block=\"true\"><strong>注意，上面的路徑要替換成你自己的使用者路徑</strong>——肯定不是<code>jetbrains</code>：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"174\" data-relingo-block=\"true\">Don’t forget to replace jetbrains with your username!</p> \n     </blockquote> \n     <p data-relin-paragraph=\"175\" data-relingo-block=\"true\">設定完後，重啟 shell，一樣，可直接在命令列打上<code>poetry</code>指令測試。</p> \n     <h3 data-relin-paragraph=\"176\" data-relingo-block=\"true\"><span title=\"設定 alias\"></span>設定 alias</h3> \n     <p data-relin-paragraph=\"177\" data-relingo-block=\"true\">比起<code>pip</code>，<code>poetry</code>這個指令實在太冗長了！我們還是給它一個 alias 吧！</p> \n     <p data-relin-paragraph=\"178\" data-relingo-block=\"true\">基於它是我極為常用的指令，我願意賦與它<strong>「單字母」的 alias 特權</strong>，我使用<code>p</code>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span><span>alias</span> p=<span>'poetry'</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"179\" data-relingo-block=\"true\">alias 是方便自己使用，但本文基於表達清晰考量，下面的解說除了圖片外，原則上並不會使用 alias 表示。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"180\" data-relingo-block=\"true\"><span title=\"初始化 Poetry\"></span>初始化 Poetry</h2> \n     <p data-relin-paragraph=\"181\" data-relingo-block=\"true\">為了方便解說，我們先建立一個全新的專案，名為<code>poetry-demo</code>。</p> \n     <p data-relin-paragraph=\"182\" data-relingo-block=\"true\">指令都很簡單，但還是建議可以一步一步跟著操作。</p> \n     <p data-relin-paragraph=\"183\" data-relingo-block=\"true\">就像 git 專案需要初始化，Poetry 也需要，因為每一個使用了 Poetry 的專案中一定要有一個<code>pyproject.toml</code>作為它的<strong>設定檔</strong>。否則直接使用<code>poetry</code>相關指令就會出現下列錯誤訊息：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"184\" data-relingo-block=\"true\">Poetry could not find a pyproject.toml file in {cwd} or its parents</p> \n     </blockquote> \n     <p data-relin-paragraph=\"185\" data-relingo-block=\"true\">所以一定先初始化，使用<code>poetry init</code>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span><span>mkdir</span> poetry-demo</span><br><span><span>cd</span> poetry-demo</span><br><span>poetry init</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"186\" data-relingo-block=\"true\">此時會跳出一連串的互動對話，協助你建立專案的資料，大部分可以直接<code>enter</code>跳過：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></pre></td> \n         <td><pre><span>This <span>command</span> will guide you through creating your pyproject.toml config.</span><br><span></span><br><span>Package name [poetry-demo]:</span><br><span>Version [0.1.0]:</span><br><span>Description []:</span><br><span>Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:</span><br><span>License []:</span><br><span>Compatible Python versions [^3.8]:</span><br><span></span><br><span>Would you like to define your main dependencies interactively? (<span>yes</span>/no) [<span>yes</span>]</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"187\" data-relingo-block=\"true\">直到出現「<code>Would you like to define your main dependencies interactively? (yes/no) [yes]</code>」，我們先選擇「<strong>no</strong>」後，會讓你確認本次產生的<code>toml</code>檔內容：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></pre></td> \n         <td><pre><span>Would you like to define your development dependencies interactively? (<span>yes</span>/no) [<span>yes</span>] no</span><br><span>Generated file</span><br><span></span><br><span>[tool.poetry]</span><br><span>name = <span>\"poetry-demo\"</span></span><br><span>version = <span>\"0.1.0\"</span></span><br><span>description = <span>\"\"</span></span><br><span>authors = [<span>\"kyo &lt;odinxp@gmail.com&gt;\"</span>]</span><br><span></span><br><span>[tool.poetry.dependencies]</span><br><span>python = <span>\"^3.8\"</span></span><br><span></span><br><span>[tool.poetry.dev-dependencies]</span><br><span></span><br><span>[build-system]</span><br><span>requires = [<span>\"poetry-core&gt;=1.0.0\"</span>]</span><br><span>build-backend = <span>\"poetry.core.masonry.api\"</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"188\" data-relingo-block=\"true\">並詢問你「<code>Do you confirm generation? (yes/no) [yes]</code>」，按<code>enter</code>使用預設選項「yes」或直接回答「yes」，則<code>pyproject.toml</code>建立完成。</p> \n     <p data-relin-paragraph=\"189\" data-relingo-block=\"true\">此時專案目錄結構如下：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td> \n         <td><pre><span>poetry-demo</span><br><span>└── pyproject.toml</span><br><span></span><br><span>0 directories, 1 file</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"190\" data-relingo-block=\"true\"><span title=\"管理 Poetry 虛擬環境\"></span>管理 Poetry 虛擬環境</h2> \n     <p data-relin-paragraph=\"191\" data-relingo-block=\"true\">我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於<strong>虛擬環境</strong>的管理。</p> \n     <h3 data-relin-paragraph=\"192\" data-relingo-block=\"true\"><span title=\"「強制」虛擬環境\"></span>「強制」虛擬環境</h3> \n     <p data-relin-paragraph=\"193\" data-relingo-block=\"true\">Poetry 預設上（可透過<code>poetry config</code>修改）會強制套件都要安裝在虛擬環境中，以免污染全域，所以它整合了<code>virtualenv</code>。</p> \n     <p data-relin-paragraph=\"194\" data-relingo-block=\"true\">所以在執行<code>poetry add、install</code>等指令時，Poetry 都會自動檢查<strong>當下是否正在使用虛擬環境：</strong></p> \n     <ul> \n      <li data-relin-paragraph=\"195\" data-relingo-block=\"true\">如果<strong>是</strong>，則會直接安裝套件至<strong>當前</strong>的虛擬環境。</li> \n      <li data-relin-paragraph=\"196\" data-relingo-block=\"true\">如果<strong>否</strong>，則會自動幫你建立一個<strong>新的</strong>虛擬環境，再進行套件安裝。</li> \n     </ul> \n     <h3 data-relin-paragraph=\"197\" data-relingo-block=\"true\"><span title=\"容易混淆的虛擬環境\"></span>容易混淆的虛擬環境</h3> \n     <p data-relin-paragraph=\"198\" data-relingo-block=\"true\">Poetry 主動納入虛擬環境管理算是立意良善，相當於把<code>pip</code>+<code>venv</code>兩者的功能直接整合在一起，<strong>但也帶來一定的複雜度</strong>，尤其在你已經自行使用了<code>venv</code>、<code>virtualenv</code>或 <code>pyenv-virtualenv</code>或<code>conda</code>等工具來管理虛擬環境的情況下！</p> \n     <blockquote> \n      <p data-relin-paragraph=\"199\" data-relingo-block=\"true\"><strong>沒錯，Python 的虛擬環境管理就是這麼麻煩！</strong></p> \n     </blockquote> \n     <p data-relin-paragraph=\"200\" data-relingo-block=\"true\">個人建議，對新手而言，於 Poetry 的專案中，<strong>一律透過 Poetry</strong> 來管理虛擬環境即可。我目前也是這樣，省得麻煩。</p> \n     <h3 data-relin-paragraph=\"201\" data-relingo-block=\"true\"><span title=\"以指令建立虛擬環境\"></span>以指令建立虛擬環境</h3> \n     <p data-relin-paragraph=\"202\" data-relingo-block=\"true\">使用指令<code>poetry env use python</code>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span>❯ poetry <span>env</span> use python</span><br><span>Creating virtualenv poetry-demo-IEWSZKSE-py3.8 <span>in</span> /Users/kyo/Library/Caches/pypoetry/virtualenvs</span><br><span>Using virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"203\" data-relingo-block=\"true\">可以看出 Poetry 為我們建立了名為<code>poetry-demo-IEWSZKSE-py3.8</code>的虛擬環境。</p> \n     <h3 data-relin-paragraph=\"204\" data-relingo-block=\"true\"><span title=\"重點說明\"></span>重點說明</h3> \n     <ul> \n      <li><code>poetry env use python</code>建立虛擬環境所使用的 Python 版本，取決於<code>python</code>指令在你的「<strong data-relin-paragraph=\"426\">PATH</strong>」是連結到哪個版本。 \n       <ul> \n        <li data-relin-paragraph=\"208\" data-relingo-block=\"true\">你也可以將指令最後的<code>python</code>，改為<code>python3</code>或<code>python3.8</code>，甚至只需要<code>3.8</code>，只要它們確實存在於 PATH 中。</li> \n        <li data-relin-paragraph=\"209\" data-relingo-block=\"true\">更多資訊可參考<a href=\"https://python-poetry.org/docs/managing-environments/\" rel=\"noopener\" target=\"_blank\">官方文件</a>。</li> \n       </ul> </li> \n      <li data-relin-paragraph=\"210\" data-relingo-block=\"true\">預設上，Poetry 會統一將虛擬環境建立在「<strong>特定目錄</strong>」裡，比如本例中存放的路徑是<code>/Users/kyo/Library/Caches/pypoetry/virtualenvs</code>。</li> \n      <li data-relin-paragraph=\"211\" data-relingo-block=\"true\">虛擬環境的<strong>命名模式為<code>專案名稱-亂數-Python版本</code>。</strong></li> \n     </ul> \n     <p data-relin-paragraph=\"212\" data-relingo-block=\"true\">最後一點，老實說我個人不是很喜歡這樣的做法，因為這意味著單一專案允許建立複數個虛擬環境（比如 Python 3.7、3.8、3.9 可以各來一個），<strong>彈性之餘也增加了混亂的可能</strong>，而且這命名模式我也不太欣賞，顯得有點冗長。</p> \n     <p data-relin-paragraph=\"213\" data-relingo-block=\"true\">既然 Python 的虛擬環境理論上都是<strong>高度綁定專案本身</strong>的，我更偏好<code>venv</code>式的做法，也就是<strong>把虛擬環境放到專案目錄內</strong>，而非統一放在獨立的目錄，讓虛擬環境與專案呈現<strong>直觀的一對一關係</strong>。</p> \n     <p data-relin-paragraph=\"214\" data-relingo-block=\"true\">所幸，Poetry 具備這樣的選項。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"215\" data-relingo-block=\"true\"><span title=\"修改config，建立專案內.venv虛擬環境\"></span>修改<code>config</code>，建立專案內<code>.venv</code>虛擬環境</h2> \n     <p data-relin-paragraph=\"216\" data-relingo-block=\"true\">我們先使用<code>poetry config</code>指令來查看 Poetry 目前幾個主要的設定，需要<code>--list</code>這個參數：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></pre></td> \n         <td><pre><span>❯ poetry config --list</span><br><span>cache-dir = <span>\"/Users/kyo/Library/Caches/pypoetry\"</span></span><br><span>experimental.new-installer = <span>true</span></span><br><span>installer.parallel = <span>true</span></span><br><span>virtualenvs.create = <span>true</span></span><br><span>virtualenvs.in-project = <span>false</span></span><br><span>virtualenvs.path = <span>\"{cache-dir}/virtualenvs\"</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"217\" data-relingo-block=\"true\">其中<code>virtualenvs.create = true</code>若改成<code>false</code>，則可以停止 Poetry 在「偵測不到虛擬環境時會自行建立」的行為模式，但建議還是不要更動。</p> \n     <p data-relin-paragraph=\"218\" data-relingo-block=\"true\">而<code>virtualenvs.in-project = false</code>就是我們要修改的目標，使用指令：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry config virtualenvs.in-project <span>true</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"219\" data-relingo-block=\"true\">好，我們先把之前建立的虛擬環境刪除：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br></pre></td> \n         <td><pre><span>❯ poetry <span>env</span> remove python</span><br><span>Deleted virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"220\" data-relingo-block=\"true\">重新建立，看看行為有何差異：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span>❯ poetry <span>env</span> use python</span><br><span>Creating virtualenv poetry-demo <span>in</span> /Users/kyo/Documents/code/poetry-demo/.venv</span><br><span>Using virtualenv: /Users/kyo/Documents/code/poetry-demo/.venv</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"221\" data-relingo-block=\"true\">可以看出：</p> \n     <ul> \n      <li data-relin-paragraph=\"222\" data-relingo-block=\"true\">虛擬環境的路徑改為「<strong>專案的根目錄</strong>」。</li> \n      <li data-relin-paragraph=\"223\" data-relingo-block=\"true\">名稱固定為<code>.venv</code>。</li> \n     </ul> \n     <p data-relin-paragraph=\"224\" data-relingo-block=\"true\">我覺得這樣的設定更加簡潔。</p> \n     <h3 data-relin-paragraph=\"225\" data-relingo-block=\"true\"><span title=\"啟動與退出虛擬環境\"></span>啟動與退出虛擬環境</h3> \n     <p data-relin-paragraph=\"226\" data-relingo-block=\"true\">啟動虛擬環境，需移至專案目錄底下，使用指令<code>poetry shell</code>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span>❯ poetry shell</span><br><span>Spawning shell within /Users/kyo/Documents/code/poetry-demo/.venv</span><br><span>❯ . /Users/kyo/Documents/code/poetry-demo/.venv/bin/activate</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"227\" data-relingo-block=\"true\"><code>poetry shell</code>指令會偵測當前目錄或所屬上層目錄是否存在<code>pyproject.toml</code>來確定所要啟動的虛擬環境，所以如果不移至專案目錄，則會出現下列錯誤：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></pre></td> \n         <td><pre><span>❯ poetry shell</span><br><span></span><br><span>  RuntimeError</span><br><span></span><br><span>  Poetry could not find a pyproject.toml file <span>in</span> /Users/kyo/Documents/code or its parents</span><br><span></span><br><span>  at ~/Library/Application Support/pypoetry/venv/lib/python3.8/site-packages/poetry/core/factory.py:369 <span>in</span> locate</span><br><span>      365│             <span>if</span> poetry_file.exists():</span><br><span>      366│                 <span>return</span> poetry_file</span><br><span>      367│</span><br><span>      368│         <span>else</span>:</span><br><span>    → 369│             raise RuntimeError(</span><br><span>      370│                 <span>\"Poetry could not find a pyproject.toml file in {} or its parents\"</span>.format(</span><br><span>      371│                     cwd</span><br><span>      372│                 )</span><br><span>      373│             )</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"228\" data-relingo-block=\"true\">可以看到，Poetry 的錯誤訊息非常清楚，讓你很容易知曉修正的方向，這是作為一個優秀命令列工具的必要條件。</p> \n     <p data-relin-paragraph=\"229\" data-relingo-block=\"true\">退出就簡單多了，只需要<code>exit</code>即可。</p> \n     <hr data-relingo-block=\"true\"> \n     <h3 data-relin-paragraph=\"230\" data-relingo-block=\"true\"><span title=\"Poetry 指令\"></span>Poetry 指令</h3> \n     <p data-relin-paragraph=\"231\" data-relingo-block=\"true\">Poetry 是一個獨立的命令列工具，就像 pyenv，它有自己的指令，需要花費額外的心力學習，且較 pip 更加複雜，這可能是使用 Poetry 的<strong>第二道關卡</strong>。好在常用的指令，其實也不超過 10 個，下面就來一一介紹。</p> \n     <p data-relin-paragraph=\"232\" data-relingo-block=\"true\">在此我們繼續使用前面提過的 Flask 和 Black 套件，來示範並說明 Poetry 的優勢以及它和 pip 的不同之處。</p> \n     <h2 data-relin-paragraph=\"233\" data-relingo-block=\"true\"><span title=\"Poetry 新增套件\"></span>Poetry 新增套件</h2> \n     <p data-relin-paragraph=\"234\" data-relingo-block=\"true\">使用指令：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"235\" data-relingo-block=\"true\">相當於<code>pip install</code>，我們來試著安裝 Flask 看看會有什麼變化：</p> \n     <p data-relingo-block=\"true\"><a title=\"\" href=\"https://i.imgur.com/H7pPtsk.png\" target=\"_blank\"><img data-cubox-image-src=\"https://i.imgur.com/H7pPtsk.png\" data-cubox-image-load=\"false\" data-cubox-image-index=\"2\" data-cubox-image- src=\"https://image.cubox.pro/cardImg/37d07aqm6ir9gscslghs34hwf8p2s473x2t8ps0zhkld9msrd7.png?imageMogr2/quality/90/ignore-error/1\" origin-src=\"https://i.imgur.com/H7pPtsk.png\" loading=\"lazy\"></a></p> \n     <p data-relin-paragraph=\"236\" data-relingo-block=\"true\">圖中可以看出 Poetry 漂亮的命令列資訊呈現，會清楚告知總共新增了幾個套件。</p> \n     <p data-relin-paragraph=\"237\" data-relingo-block=\"true\">此時專案中的<code>pyproject.toml</code>也會發生變化：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td> \n         <td><pre><span>...</span><br><span>[tool.poetry.dependencies]</span><br><span>python = <span>\"^3.8\"</span></span><br><span>Flask = <span>\"^2.1.1\"</span>  <span># 新增部分</span></span><br><span></span><br><span>[tool.poetry.dev-dependencies]</span><br><span></span><br><span>[build-system]</span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"238\" data-relingo-block=\"true\">這裡要說明，安裝 Flask，則<code>pyproject.toml</code>就只會新增記載<code>Flask = \"^2.1.1\"</code>這個 <strong>top-level</strong> 的 package 項目，其餘的依賴套件<strong>不會</strong>直接記錄在<code>toml</code>檔中。</p> \n     <p data-relin-paragraph=\"239\" data-relingo-block=\"true\">我覺得這是一大優點，方便區分哪些是你<strong>主動安裝</strong>的主要套件，而哪些又是基於套件的依賴關係而一併安裝的依賴套件。</p> \n     <h3 data-relin-paragraph=\"240\" data-relingo-block=\"true\"><span title=\"poetry.lock與更新順序\"></span><code>poetry.lock</code>與更新順序</h3> \n     <p data-relin-paragraph=\"241\" data-relingo-block=\"true\">除了更新<code>pyproject.toml</code>，此時專案中還會新增一個檔案，名為<code>poetry.lock</code>，它實際上就相當於 pip 的<code>requirements.txt</code>，詳細記載了所有安裝的套件與版本。</p> \n     <p data-relin-paragraph=\"242\" data-relingo-block=\"true\">當你使用<code>poetry add</code>指令時，Poetry 會<strong>自動依序</strong>幫你做完這<strong>三件事</strong>：</p> \n     <ol> \n      <li data-relin-paragraph=\"243\" data-relingo-block=\"true\">更新<code>pyproject.toml</code>。</li> \n      <li data-relin-paragraph=\"244\" data-relingo-block=\"true\">依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。</li> \n      <li data-relin-paragraph=\"245\" data-relingo-block=\"true\">依照<code>poetry.lock</code>的內容，更新虛擬環境。</li> \n     </ol> \n     <p data-relin-paragraph=\"246\" data-relingo-block=\"true\">由此可見，<code>poetry.lock</code>的內容是取決於<code>pyproject.toml</code>，但兩者並不會自己連動，一定要基於特定指令才會進行同步與更新，<code>poetry add</code>就是一個典型案例。</p> \n     <p data-relin-paragraph=\"247\" data-relingo-block=\"true\">此時專案目錄結構如下：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></pre></td> \n         <td><pre><span>poetry-demo</span><br><span>├── poetry.lock</span><br><span>└── pyproject.toml</span><br><span></span><br><span>0 directories, 2 files</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <h3 data-relin-paragraph=\"248\" data-relingo-block=\"true\"><span title=\"poetry lock：更新 poetry.lock\"></span><code>poetry lock</code>：更新 poetry.lock</h3> \n     <p data-relin-paragraph=\"249\" data-relingo-block=\"true\">當你自行修改了<code>pyproject.toml</code>內容，比如變更特定套件的版本（這是有可能的，尤其在手動處理版本衝突的時候），此時<code>poetry.lock</code>的內容與<code>pyproject.toml</code>出現了「<strong>脫鉤</strong>」，必須讓它依照新的<code>pyproject.toml</code>內容更新、同步，使用指令：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry lock</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"250\" data-relingo-block=\"true\">如此一來，才能確保手動修改的內容，也更新到<code>poetry.lock</code>中，畢竟虛擬環境如果要重新建立，<strong>是基於<code>poetry.lock</code>的內容來安裝套件</strong>，而非<code>pyproject.toml</code>。</p> \n     <p data-relin-paragraph=\"251\" data-relingo-block=\"true\">還是那句話：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"252\" data-relingo-block=\"true\"><code>poetry.lock</code>相當於 Poetry 的<code>requirements.txt</code>。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"253\" data-relingo-block=\"true\">但要特別注意的是，<code>poetry lock</code>指令，<strong>僅會更新</strong><code>poetry.lock</code>，<strong>「不會」同時安裝</strong>套件至虛擬環境：</p> \n     <blockquote> \n      <p data-relin-paragraph=\"254\" data-relingo-block=\"true\">This command locks (<strong>without installing</strong>) the dependencies specified in pyproject.toml.</p> \n     </blockquote> \n     <p data-relin-paragraph=\"255\" data-relingo-block=\"true\">因此，在執行完<code>poetry lock</code>指令後，你必須再使用<code>poetry install</code>來安裝套件。否則就會出現<code>poetry.lock</code>和虛擬環境<strong>不一致</strong>的狀況。</p> \n     <p data-relin-paragraph=\"256\" data-relingo-block=\"true\">更多<code>poetry lock</code>細節可參考<a href=\"https://python-poetry.org/docs/cli/#lock\" rel=\"noopener\" target=\"_blank\">官方文件</a>，其中特別值得注意的是<code>--no-update</code>參數。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"257\" data-relingo-block=\"true\"><span title=\"指定套件「版本」範圍\"></span>指定套件「版本」範圍</h2> \n     <blockquote> \n      <p data-relin-paragraph=\"258\" data-relingo-block=\"true\"><code>2024/01/05</code>新增。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"259\" data-relingo-block=\"true\">回想我們使用 pip 的時候，<code>requirements.txt</code>的內容通常是長這樣：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></pre></td> \n         <td><pre><span>blinker==1.6.3</span><br><span>click==8.1.7</span><br><span>flask==3.0.0</span><br><span>itsdangerous==2.1.2</span><br><span>jinja2==3.1.2</span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"260\" data-relingo-block=\"true\">所有套件的版本都是<strong>固定</strong>的！</p> \n     <p data-relin-paragraph=\"261\" data-relingo-block=\"true\">如前所述，那是因為 pip 並不擅長管理套件的版本衝突，所以固定是<strong>最保險的</strong>。但代價是，<strong>專案無法輕易更新套件版本，容易過時，造成後續開發與維護的麻煩</strong>。</p> \n     <p data-relin-paragraph=\"262\" data-relingo-block=\"true\">你可以試著手動修改<code>requirements.txt</code>，但隨之而來的是一陣陣<strong>手動處理版本衝突的痛苦</strong>😱</p> \n     <h3 data-relin-paragraph=\"263\" data-relingo-block=\"true\"><span title=\"Poetry 的版本管理能力\"></span>Poetry 的版本管理能力</h3> \n     <p data-relin-paragraph=\"264\" data-relingo-block=\"true\">使用 Poetry，情況將<strong>大不相同</strong>，因為 Poetry 能夠管理套件的版本衝突，所以我們可以<strong>放心</strong>地透過「<strong>範圍</strong>」來指定套件的版本。</p> \n     <p data-relin-paragraph=\"265\" data-relingo-block=\"true\">這樣的好處是，在<strong>不影響專案穩定性（不發生套件版本衝突）</strong>的前提下，<strong>自動更新</strong>套件至<strong>範圍內的最新版</strong>，且不需要手動修改<code>pyproject.toml</code>。</p> \n     <p data-relin-paragraph=\"266\" data-relingo-block=\"true\">當然，如果你認為這不夠保險，還是可以在安裝時，指定套件的「特定」版本。或後續手動修改<code>pyproject.toml</code>，讓套件版本固定。</p> \n     <p data-relin-paragraph=\"267\" data-relingo-block=\"true\">Poetry 的<code>add</code>指令，可以用下列方式指定套件版本（前二者須搭配<code>@</code>運算子），我們以安裝 Django 4.2 LTS 為例。</p> \n     <h3 data-relin-paragraph=\"268\" data-relingo-block=\"true\"><span title=\"一、使用^符號（文件）\"></span>一、使用<code>^</code>符號（<a href=\"https://python-poetry.org/docs/dependency-specification/#caret-requirements\" rel=\"noopener\" target=\"_blank\">文件</a>）</h3> \n     <p data-relin-paragraph=\"269\" data-relingo-block=\"true\">指定 Django 版本為 &gt;=4.2.9 且 &lt;5.0.0（允許 4.2.9 及以上版本，但不包括 5.0.0，即最大版號不能變更）:</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add django@^4.2.9</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"270\" data-relingo-block=\"true\">這意味著<strong>它會接受所有 4.x.x 的更新</strong>，只要版本號小於 5.0.0。這是一個常見的做法，因為它允許套件自動更新到<strong>任何非重大變更</strong>的新版本。</p> \n     <h3 data-relin-paragraph=\"271\" data-relingo-block=\"true\"><span title=\"二、使用~符號（文件）\"></span>二、使用<code>~</code>符號（<a href=\"https://python-poetry.org/docs/dependency-specification/#tilde-requirements\" rel=\"noopener\" target=\"_blank\">文件</a>）</h3> \n     <p data-relin-paragraph=\"272\" data-relingo-block=\"true\">指定 Django 版本為 &gt;=4.2.9 且 &lt;4.3.0（允許 4.2.9 及以上版本，但不包括 4.3.0，即<strong>只能升級最小版號</strong>）:</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add django@~4.2.9</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"273\" data-relingo-block=\"true\">這個選項<strong>更加保守</strong>，<strong>只會接受 4.2.x 系列的更新</strong>。這適合想要<strong>進一步限制</strong>更新的範圍，但又保留一些更新的彈性——僅包括 bug 修正和小幅度的改進。</p> \n     <h3 data-relin-paragraph=\"274\" data-relingo-block=\"true\"><span title=\"三、使用>=符號\"></span>三、使用<code>&gt;=</code>符號</h3> \n     <p data-relin-paragraph=\"275\" data-relingo-block=\"true\">指定 Django 版本為 &gt;=4.2.9（沒有上限）:</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br></pre></td> \n         <td><pre><span><span># 注意，這裡需要使用「字串」表示</span></span><br><span>poetry add <span>\"django&gt;=4.2.9\"</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"276\" data-relingo-block=\"true\"><strong>主版號</strong>（即上面的 4.x.x 中的 4）<strong>升級</strong>時，通常有更大機率引入 <strong>API 變更</strong>、棄用舊有的 API 等，也就是所謂的 <strong>breaking change。</strong></p> \n     <p data-relin-paragraph=\"277\" data-relingo-block=\"true\">這樣的更新可能會導致你的專案無法正常運作，需要一併修改程式碼。所以一般<strong>不建議</strong>使用這種方式。</p> \n     <h3 data-relin-paragraph=\"278\" data-relingo-block=\"true\"><span title=\"四、固定版本\"></span>四、固定版本</h3> \n     <p data-relin-paragraph=\"279\" data-relingo-block=\"true\">僅允許 Django 的 4.2.9 版本（<strong>嚴格限制</strong>在這個版本）:</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add django==4.2.9</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"280\" data-relingo-block=\"true\">安全、保險，但也<strong>浪費</strong>了 Poetry 的版本管理能力。</p> \n     <p data-relin-paragraph=\"281\" data-relingo-block=\"true\">一般我只在 linter、formatter 等工具上使用固定版本，自己手動更新。因為<strong>它們必須和 pre-commit 設定檔中的版本一致</strong>。所以我不會讓它們自動升級。</p> \n     <hr data-relingo-block=\"true\"> \n     <p data-relin-paragraph=\"282\" data-relingo-block=\"true\">依我個人經驗，<strong>最常用的是第 1 和第 4 種方式。</strong></p> \n     <h3 data-relin-paragraph=\"283\" data-relingo-block=\"true\"><span title=\"一次安裝複數套件\"></span>一次安裝複數套件</h3> \n     <p data-relin-paragraph=\"284\" data-relingo-block=\"true\">Poetry 的<code>add</code>指令，也可以一次安裝複數套件，比如：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add django@^4.2.9 requests@^2.26.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"285\" data-relingo-block=\"true\">或不指定版本：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry add django requests</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"286\" data-relingo-block=\"true\"><span title=\"新增套件至 dev-dependencies\"></span>新增套件至 dev-dependencies</h2> \n     <p data-relin-paragraph=\"287\" data-relingo-block=\"true\">有些套件，比如<code>pytest</code>、<code>flake8</code>等等，<strong>只會在開發環境中使用</strong>，產品的<strong>部署環境</strong>並不需要。</p> \n     <p data-relin-paragraph=\"288\" data-relingo-block=\"true\">Poetry 允許你<strong>區分</strong>這兩者，將上述的套件安裝至<code>dev-dependencies</code>區塊，方便讓你<strong>輕鬆建立一份「不包含」<code>dev-dependencies</code>開發套件的安裝清單</strong>。</p> \n     <p data-relin-paragraph=\"289\" data-relingo-block=\"true\">在此以 Black 為例，安裝指令如下，<strong>舊版</strong>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span>poetry add black --dev</span><br><span><span># 或</span></span><br><span>poetry add black -D</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"290\" data-relingo-block=\"true\"><strong>新版，Poetry &gt;= 1.2.0</strong>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td> \n         <td><pre><span>poetry add black --group dev</span><br><span><span># 或</span></span><br><span>poetry add black -G dev</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"291\" data-relingo-block=\"true\">結果的區別顯示在<code>pyproject.toml</code>裡：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td> \n         <td><pre><span>...</span><br><span>[tool.poetry.dependencies]</span><br><span>python = <span>\"^3.8\"</span></span><br><span>Flask = <span>\"^2.1.1\"</span></span><br><span></span><br><span>[tool.poetry.dev-dependencies]</span><br><span>black = <span>\"^22.3.0\"</span></span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"292\" data-relingo-block=\"true\">可以看到<code>black</code>被列在不同區塊：<code>tool.poetry.dev-dependencies</code>。</p> \n     <h3 data-relin-paragraph=\"293\" data-relingo-block=\"true\"><span title=\"強烈建議善用 dev-dependencies\"></span>強烈建議善用 dev-dependencies</h3> \n     <p data-relin-paragraph=\"294\" data-relingo-block=\"true\">善用<code>-D</code>參數，明確區分<strong>開發環境專用</strong>的套件，我認為<strong>非常必要</strong>。</p> \n     <p data-relin-paragraph=\"295\" data-relingo-block=\"true\">首先，這些套件常常屬於「<strong>檢測型</strong>」工具，相關的<strong>依賴套件</strong>著實不少！比如<code>flake8</code>，它依賴了<code>pycodestyle</code>、<code>pyflakes</code>、<code>mccabe</code>等等，還有<code>black</code>、<code>pre-commit</code>，依賴套件數量也都很可觀。</p> \n     <p data-relin-paragraph=\"296\" data-relingo-block=\"true\">其次，既然它們都只在開發階段才需要，則完全可以從部署環境中<strong>缺席</strong>。如果不分青紅皂白一律安裝到<code>dependencies</code>區塊，部署環境容易顯得過於<strong>臃腫</strong>。</p> \n     <p data-relin-paragraph=\"297\" data-relingo-block=\"true\">常見的<code>dev-dependencies</code>區塊項目，例示如下：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td> \n         <td><pre><span><span>[tool.poetry.dev-dependencies]</span></span><br><span><span>flake8</span> = <span>\"4.0.1\"</span></span><br><span><span>yapf</span> = <span>\"0.32.0\"</span></span><br><span><span>pytest</span> = <span>\"7.1.2\"</span></span><br><span><span>pytest-django</span> = <span>\"4.5.2\"</span></span><br><span><span>pytest-cov</span> = <span>\"3.0.0\"</span></span><br><span><span>pytest-env</span> = <span>\"0.6.2\"</span></span><br><span><span>pytest-sugar</span> = <span>\"0.9.4\"</span></span><br><span><span>pre-commit</span> = <span>\"2.20.0\"</span></span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"298\" data-relingo-block=\"true\"><span title=\"Poetry 更新套件\"></span>Poetry 更新套件</h2> \n     <p data-relin-paragraph=\"299\" data-relingo-block=\"true\">這個就很簡單了，使用<code>poetry update</code>指令即可：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry update</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"300\" data-relingo-block=\"true\">上面指令會更新<strong>全部</strong>「<strong>可能可以更新</strong>」的套件，你也可以<strong>僅指定</strong>特定套件，比如：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry update requests toml</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"301\" data-relingo-block=\"true\">關於<code>poetry update</code>的其餘參數，請參考<a href=\"https://python-poetry.org/docs/cli/#update\" rel=\"noopener\" target=\"_blank\">文件</a>。</p> \n     <p data-relin-paragraph=\"302\" data-relingo-block=\"true\">還一件<strong>重要的事</strong>，那就是關於<strong>套件版本的升級限制規則</strong>，取決於你在<code>pyproject.toml</code>中的設定。</p> \n     <p data-relin-paragraph=\"303\" data-relingo-block=\"true\">這部分稍嫌複雜，且有多種表達方式，可見 <a href=\"https://python-poetry.org/docs/dependency-specification/\" rel=\"noopener\" target=\"_blank\">Dependency specification</a>。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"304\" data-relingo-block=\"true\"><span title=\"列出全部套件清單\"></span>列出全部套件清單</h2> \n     <p data-relin-paragraph=\"305\" data-relingo-block=\"true\">類似<code>pip list</code>，這裡要使用<code>poetry show</code>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></pre></td> \n         <td><pre><span>❯ poetry show</span><br><span>black              22.3.0 The uncompromising code formatter.</span><br><span>click              8.1.3  Composable <span>command</span> line interface toolkit</span><br><span>flask              2.1.2  A simple framework <span>for</span> building complex web applications.</span><br><span>importlib-metadata 4.11.4 Read metadata from Python packages</span><br><span>itsdangerous       2.1.2  Safely pass data to untrusted environments and back.</span><br><span>jinja2             3.1.2  A very fast and expressive template engine.</span><br><span>markupsafe         2.1.1  Safely add untrusted strings to HTML/XML markup.</span><br><span>mypy-extensions    0.4.3  Experimental <span>type</span> system extensions <span>for</span> programs checked...</span><br><span>pathspec           0.9.0  Utility library <span>for</span> gitignore style pattern matching of ...</span><br><span>platformdirs       2.5.2  A small Python module <span>for</span> determining appropriate platfo...</span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"306\" data-relingo-block=\"true\">特別提醒的是，這裡的清單內容<strong>並不是來自於虛擬環境</strong>，這點和 pip 不同，而是來自於<code>poetry.lock</code>的內容。</p> \n     <p data-relin-paragraph=\"307\" data-relingo-block=\"true\">你可能會想，來自於<code>poetry.lock</code>或虛擬環境，有差嗎？兩者不是應該要一致？</p> \n     <p data-relin-paragraph=\"308\" data-relingo-block=\"true\">沒錯，理論上是，但也有不一致的時候，比如你使用了<code>pip install</code>指令安裝套件，就不會記載在<code>poetry.lock</code>中，那<code>poetry show</code>自然也不會顯示。</p> \n     <h3 data-relin-paragraph=\"309\" data-relingo-block=\"true\"><span title=\"「樹狀」顯示套件依賴層級\"></span>「樹狀」顯示套件依賴層級</h3> \n     <p data-relin-paragraph=\"310\" data-relingo-block=\"true\">Poetry 最為人津津樂道的就是它的樹狀顯示——<code>poetry show --tree</code>。</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></pre></td> \n         <td><pre><span>❯ poetry show --tree</span><br><span>flask 2.1.1 A simple framework <span>for</span> building complex web applications.</span><br><span>├── click &gt;=8.0</span><br><span>│   └── colorama *</span><br><span>├── importlib-metadata &gt;=3.6.0</span><br><span>│   └── zipp &gt;=0.5</span><br><span>├── itsdangerous &gt;=2.0</span><br><span>├── jinja2 &gt;=3.0</span><br><span>│   └── markupsafe &gt;=2.0</span><br><span>└── werkzeug &gt;=2.0</span><br><span>black 22.3.0 The uncompromising code formatter.</span><br><span>├── click &gt;=8.0.0</span><br><span>│   └── colorama *</span><br><span>├── mypy-extensions &gt;=0.4.3</span><br><span>├── pathspec &gt;=0.9.0</span><br><span>├── platformdirs &gt;=2</span><br><span>├── tomli &gt;=1.1.0</span><br><span>└── typing-extensions &gt;=3.10.0.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"311\" data-relingo-block=\"true\">讓主要套件與其依賴套件的<strong>關係與層次，一目了然</strong>。</p> \n     <p data-relin-paragraph=\"312\" data-relingo-block=\"true\">而且很貼心的是，它也可以<strong>只顯示「指定套件」</strong>的依賴層級，以<code>celery</code>為例：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></pre></td> \n         <td><pre><span>❯ poetry show celery --tree</span><br><span>celery 4.4.0 Distributed Task Queue.</span><br><span>├── billiard &gt;=3.6.1,&lt;4.0</span><br><span>├── kombu &gt;=4.6.7,&lt;4.7</span><br><span>│   ├── amqp &gt;=2.6.0,&lt;2.7</span><br><span>│   │   └── vine &gt;=1.1.3,&lt;5.0.0a1</span><br><span>│   └── importlib-metadata &gt;=0.18</span><br><span>│       ├── typing-extensions &gt;=3.6.4</span><br><span>│       └── zipp &gt;=0.5</span><br><span>├── pytz &gt;0.0-dev</span><br><span>└── vine 1.3.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"313\" data-relingo-block=\"true\"><span title=\"Poetry 移除套件\"></span>Poetry 移除套件</h2> \n     <p data-relin-paragraph=\"314\" data-relingo-block=\"true\">使用<code>poetry remove</code>指令。和<code>poetry add</code>一樣，可以加上<code>-D</code>參數來移除置於開發區的套件。</p> \n     <p data-relin-paragraph=\"315\" data-relingo-block=\"true\">而移除套件時的「<strong>依賴解析（相依性管理）</strong>」能力，正是 Poetry 遠優於 pip 的主要環節，因為 pip 沒有嘛！也是我提議改用 Poetry 的關鍵理由——<strong>為了順利移除套件</strong>。</p> \n     <p data-relin-paragraph=\"316\" data-relingo-block=\"true\">前面已經提過，pip 的<code>pip uninstall</code>只會移除你所指定的套件，而不會連同依賴套件一起移除。</p> \n     <p data-relin-paragraph=\"317\" data-relingo-block=\"true\">這是基於安全考量，因為 pip 沒有「依賴解析」功能。如果貿然移除所有「安裝時一併安裝」的依賴套件，可能會造成巨大災難，讓別的套件失去效用。</p> \n     <p data-relin-paragraph=\"318\" data-relingo-block=\"true\">前面也舉了 Flask 和 Black 都共同依賴<code>click</code>這個套件的例子，在手動移除套件的情況下，你可能未曾注意 Black 也依賴了<code>click</code>，結果為了「徹底移除」Flask 的所有相關套件，不小心把<code>click</code>也移除掉了。</p> \n     <p data-relin-paragraph=\"319\" data-relingo-block=\"true\">所以，使用 pip 時，我們鮮少會去移除已經不再使用的套件。畢竟<strong>依賴關係錯綜複雜</strong>，移除套件可能造成許多「<strong>副作用</strong>」，實在是太麻煩了。</p> \n     <h3 data-relin-paragraph=\"320\" data-relingo-block=\"true\"><span title=\"poetry remove的依賴解析\"></span><code>poetry remove</code>的依賴解析</h3> \n     <p data-relin-paragraph=\"321\" data-relingo-block=\"true\">好，解釋了很多，接下來就是 Poetry 的表演了，它會幫你處理這些棘手的「套件相依性」難題，讓你輕鬆移除 Flask 而不影響 Black：</p> \n     <p><a title=\"poetry remove flask\" href=\"https://i.imgur.com/79TycuL.png\" target=\"_blank\"><img data-cubox-image-src=\"https://i.imgur.com/79TycuL.png\" data-cubox-image-load=\"false\" data-cubox-image-index=\"3\" data-cubox-image- src=\"https://image.cubox.pro/cardImg/4he3m2msvbdyarrucrh8tpd52en8gsfs3gy42n2gyom7rg4vk2.png?imageMogr2/quality/90/ignore-error/1\" origin-src=\"https://i.imgur.com/79TycuL.png\" loading=\"lazy\"></a><span data-relin-paragraph=\"322\" data-relingo-block=\"true\">poetry remove flask</span></p> \n     <p data-relin-paragraph=\"323\" data-relingo-block=\"true\">可以對比上面安裝 Flask 時的截圖，那時總共安裝了 8 個套件，但現在移除的卻只有 7 個——沒錯，因為有依賴解析，<strong>Poetry 知道 Black 還需要</strong><code>click</code>！所以不能移除：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td> \n         <td><pre><span>❯ poetry show --tree</span><br><span>black 22.3.0 The uncompromising code formatter.</span><br><span>├── click &gt;=8.0.0</span><br><span>│   └── colorama *</span><br><span>├── mypy-extensions &gt;=0.4.3</span><br><span>├── pathspec &gt;=0.9.0</span><br><span>├── platformdirs &gt;=2</span><br><span>├── tomli &gt;=1.1.0</span><br><span>└── typing-extensions &gt;=3.10.0.0</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"324\" data-relingo-block=\"true\">一個套件直到環境中的<strong>其餘套件都不再依賴它</strong>，Poetry 才會安心讓它被移除。</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"325\" data-relingo-block=\"true\"><span title=\"輸出 requirements.txt\"></span>輸出 requirements.txt</h2> \n     <p data-relin-paragraph=\"326\" data-relingo-block=\"true\">理論上，全面改用 Poetry 後，專案中是不需要存在<code>requirements.txt</code>，因為它的角色已經完全被<code>poetry.lock</code>所取代。</p> \n     <p data-relin-paragraph=\"327\" data-relingo-block=\"true\">但事實是，<strong>你可能還是需要它，甚至希望它隨著<code>poetry.lock</code>的內容更新！</strong>至少對我而言就是如此，我在 Docker 部署環境中並不使用 Poetry，所以我需要一份<strong>完全等價於<code>poetry.lock</code>的<code>requirements.txt</code>，</strong>用於 Docker 部署。</p> \n     <p data-relin-paragraph=\"328\" data-relingo-block=\"true\">你可能想說，那我就在 Poetry 的虛擬環境下，使用以往熟悉的指令<code>pip freeze &gt; requirements.txt</code>來產生一份就可以了吧？我本來也是這麼想，但實際的產出卻是如此：（提醒：目前 poetry-demo 專案中<strong>僅剩下 Black 和它的依賴套件</strong>）</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td> \n         <td><pre><span>black @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/11/4c/fc/cd6d885e9f5be135b161e365b11312cff5920d7574c8446833d7a9b1a3/black-22.3.0-cp38-cp38-macosx_10_9_x86_64.whl</span><br><span>click @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/f0/23/09/b13d61d1fa8b3cd7c26f67505638d55002e7105849de4c4432c28e1c0d/click-8.1.2-py3-none-any.whl</span><br><span>mypy-extensions @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/b6/a0/b0/a5dc9acd6fd12aba308634f21bb7cf0571448f20848797d7ecb327aa12/mypy_extensions-0.4.3-py2.py3-none-any.whl</span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"329\" data-relingo-block=\"true\">這呈現好像不是我們以前熟悉的那樣：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td> \n         <td><pre><span>black==22.3.0</span><br><span>click==8.1.2</span><br><span>mypy_extensions==0.4.3</span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"330\" data-relingo-block=\"true\">沒錯，只要是使用<code>poetry add</code>安裝的套件，在<code>pip freeze</code>就會變成這樣。此時想輸出類似<code>requirements.txt</code>的格式，需要使用<code>poetry export</code>。</p> \n     <p data-relin-paragraph=\"331\" data-relingo-block=\"true\">預設的輸出結果會有 hash 值，很干擾閱讀。不想納入 hash 則要<strong>加上參數</strong>去除。<strong>以下就是我固定用來輸出<code>requirements.txt</code>的指令與參數：</strong></p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry <span>export</span> -f requirements.txt -o requirements.txt --without-hashes</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <blockquote> \n      <p data-relin-paragraph=\"332\" data-relingo-block=\"true\"><code>2022/08/24</code>補充：網友提醒，<strong>hash 有其價值，並建議保留</strong>，詳見<a href=\"https://github.com/kyomind/blog-reply/issues/5#issuecomment-1195904820\" rel=\"noopener\" target=\"_blank\">留言區</a>。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"333\" data-relingo-block=\"true\">我們再看一下輸出結果，雖然不盡相同，但也相去不遠了……嗎？等等，怎麼是空白？</p> \n     <h3 data-relin-paragraph=\"334\" data-relingo-block=\"true\"><span title=\"輸出 dev-dependencies\"></span>輸出 dev-dependencies</h3> \n     <p data-relin-paragraph=\"335\" data-relingo-block=\"true\">因為<code>poetry export</code><strong>預設</strong>只會輸出<code>toml</code>中的<code>[tool.poetry.dependencies]</code>區塊的套件！還記得上面我們把 Black 安裝到<code>[tool.poetry.dev-dependencies]</code>了嗎？</p> \n     <p data-relin-paragraph=\"336\" data-relingo-block=\"true\">顯然 Poetry 認為你 export 基本上就為了部署，並不需要開發區的套件。</p> \n     <p data-relin-paragraph=\"337\" data-relingo-block=\"true\">這倒是沒錯，不過基於演示需求，我們必須輸出<code>[tool.poetry.dev-dependencies]</code>的套件，才能看到 Black。</p> \n     <p data-relin-paragraph=\"338\" data-relingo-block=\"true\">加上<code>--dev</code>參數即可（<a href=\"https://python-poetry.org/docs/cli/#options-13\" rel=\"noopener\" target=\"_blank\">新版</a>須使用<code>--with dev</code>參數）：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span>poetry <span>export</span> -f requirements.txt -o requirements.txt --without-hashes --dev</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"339\" data-relingo-block=\"true\">輸出的<code>requirements.txt</code>內容：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td> \n         <td><pre><span>black==22.3.0; python_full_version &gt;= <span>\"3.6.2\"</span></span><br><span>click==8.1.2; python_version &gt;= <span>\"3.7\"</span> and python_full_version &gt;= <span>\"3.6.2\"</span></span><br><span>colorama==0.4.4; python_version &gt;= <span>\"3.7\"</span> and python_full_version &gt;= <span>\"3.6.2\"</span> and platform_system == <span>\"Windows\"</span></span><br><span>...</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"340\" data-relingo-block=\"true\">雖然長得有點不一樣，但這個檔案確實是可以<code>pip install</code>的。</p> \n     <p data-relin-paragraph=\"341\" data-relingo-block=\"true\">從這裡也可以看出先前一再提及「<strong>區分開發、部署套件</strong>」的價值——大部分時候我們並不需要輸出開發用套件。</p> \n     <p data-relin-paragraph=\"342\" data-relingo-block=\"true\"><code>poetry export</code>所有參數用法與說明，請參考<a href=\"https://python-poetry.org/docs/cli/#export\" rel=\"noopener\" target=\"_blank\">文件</a>。</p> \n     <p data-relin-paragraph=\"343\" data-relingo-block=\"true\">此時專案目錄結構如下：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></pre></td> \n         <td><pre><span>poetry-demo</span><br><span>├── poetry.lock</span><br><span>├── pyproject.toml</span><br><span>└── requirements.txt</span><br><span></span><br><span>0 directories, 3 files</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"344\" data-relingo-block=\"true\"><span title=\"Poetry 常用指令清單\"></span>Poetry 常用指令清單</h2> \n     <p data-relin-paragraph=\"345\" data-relingo-block=\"true\">算來算去，Poetry 的常用指令主要有下面幾個：</p> \n     <ul> \n      <li data-relin-paragraph=\"346\" data-relingo-block=\"true\"><code>poetry add</code></li> \n      <li data-relin-paragraph=\"347\" data-relingo-block=\"true\"><code>poetry remove</code></li> \n      <li data-relin-paragraph=\"348\" data-relingo-block=\"true\"><code>poetry export</code></li> \n      <li data-relin-paragraph=\"349\" data-relingo-block=\"true\"><code>poetry env use</code></li> \n      <li data-relin-paragraph=\"350\" data-relingo-block=\"true\"><code>poetry shell</code></li> \n      <li data-relin-paragraph=\"351\" data-relingo-block=\"true\"><code>poetry show</code></li> \n      <li data-relin-paragraph=\"352\" data-relingo-block=\"true\"><code>poetry init</code></li> \n      <li data-relin-paragraph=\"353\" data-relingo-block=\"true\"><code>poetry install</code></li> \n     </ul> \n     <p data-relin-paragraph=\"354\" data-relingo-block=\"true\">其中一半，單一專案可能只會用個一兩次而已，比如<code>init</code>、<code>install</code>和<code>env use</code>，實際上需要學習的指令並不多。</p> \n     <p data-relin-paragraph=\"355\" data-relingo-block=\"true\">那麼，只要知曉這些指令，就可以順利運用 Poetry 了嗎？可能是，也可能否，所以我下面還會再補充 Poetry 的常見使用情境與操作方式，讓你接納 Poetry 的阻力可以進一步下降！</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"356\" data-relingo-block=\"true\"><span title=\"Poetry 常見使用情境與操作 QA\"></span>Poetry 常見使用情境與操作 QA</h2> \n     <p data-relin-paragraph=\"357\" data-relingo-block=\"true\">這部分會以「<strong>使用場景</strong>」的角度切入，介紹 Poetry 應用情境與操作說明，還包括一些自問自答：</p> \n     <ol> \n      <li data-relin-paragraph=\"358\" data-relingo-block=\"true\"><span>新增專案並使用 Poetry</span></li> \n      <li data-relin-paragraph=\"359\" data-relingo-block=\"true\"><span>現有專案改用 Poetry</span></li> \n      <li data-relin-paragraph=\"360\" data-relingo-block=\"true\"><span>在別台主機上重現專案的 Poetry 虛擬環境</span></li> \n      <li data-relin-paragraph=\"361\" data-relingo-block=\"true\"><span>我想要移除並重建虛擬環境</span></li> \n      <li data-relin-paragraph=\"362\" data-relingo-block=\"true\"><span>為什麼我不在 Docker 環境中使用 Poetry？</span></li> \n      <li data-relin-paragraph=\"363\" data-relingo-block=\"true\"><span>我可以使用自己習慣的 virtualenv 嗎？</span></li> \n     </ol> \n     <h3 data-relin-paragraph=\"364\" data-relingo-block=\"true\"><span title=\"一、新增專案並使用 Poetry\"></span>一、新增專案並使用 Poetry</h3> \n     <p data-relin-paragraph=\"365\" data-relingo-block=\"true\">這是最理想的狀態，沒有過去的「包袱」，可謂是最能輕鬆採用 Poetry 的情境。</p> \n     <p data-relin-paragraph=\"366\" data-relingo-block=\"true\">使用順序不外乎是：</p> \n     <ol> \n      <li data-relin-paragraph=\"367\" data-relingo-block=\"true\"><code>poetry init</code>：初始化，建立<code>pyproject.toml</code>。</li> \n      <li data-relin-paragraph=\"368\" data-relingo-block=\"true\"><code>poetry env use python</code>：建立專案虛擬環境並使用。</li> \n      <li data-relin-paragraph=\"369\" data-relingo-block=\"true\"><code>poetry shell</code>：進入專案但虛擬環境還未啟動，以這個指令啟動。如果使用本指令時虛擬環境<strong>尚未建立或已移除</strong>，則會<strong>直接自動幫你建立虛擬環境</strong>並使用。</li> \n      <li data-relin-paragraph=\"370\" data-relingo-block=\"true\"><code>poetry add</code>：安裝套件並寫入虛擬環境。必要時使用<code>-D</code>參數，使其安裝至 dev 區塊。</li> \n      <li data-relin-paragraph=\"371\" data-relingo-block=\"true\"><code>poetry remove</code>：移除套件，若是移除 dev 區塊的套件，需要加上<code>-D</code>參數。</li> \n     </ol> \n     <p data-relin-paragraph=\"372\" data-relingo-block=\"true\">這部分和前面內容沒有差別，因為前面內容就是以全新專案作為基礎。</p> \n     <h3 data-relin-paragraph=\"373\" data-relingo-block=\"true\"><span title=\"二、現有專案改用 Poetry\"></span>二、現有專案改用 Poetry</h3> \n     <p data-relin-paragraph=\"374\" data-relingo-block=\"true\">極為常見的需求，但並沒有很正式的做法，因為不存在<code>poetry import</code>之類的指令。</p> \n     <p data-relin-paragraph=\"375\" data-relingo-block=\"true\">首先要考量的就是：要怎麼把<code>requirements.txt</code>的所有項目加到<code>pyproject.toml</code>中呢？經過一番 Google，基本上<a href=\"https://stackoverflow.com/questions/62764148/how-to-import-requirements-txt-from-an-existing-project-using-poetry\" rel=\"noopener\" target=\"_blank\">只能土法煉鋼</a>：</p> \n     <figure> \n      <table> \n       <tbody> \n        <tr> \n         <td><pre><span>1</span><br></pre></td> \n         <td><pre><span><span>cat</span> requirements.txt | xargs poetry add</span><br></pre></td> \n        </tr> \n       </tbody> \n      </table> \n     </figure> \n     <p data-relin-paragraph=\"376\" data-relingo-block=\"true\">然而這樣做是有可能遇到一些問題的，因為 Poetry <strong>對套件的版本衝突比較敏感</strong>，所以即便用<code>pip install -r requirements.txt</code>都能正常安裝，透過上述指令的遷移過程卻仍有機會出現錯誤。</p> \n     <p data-relin-paragraph=\"377\" data-relingo-block=\"true\">那怎麼辦？只能照著錯誤訊息手動修正<code>requirements.txt</code>中的套件版本。</p> \n     <p data-relin-paragraph=\"378\" data-relingo-block=\"true\">只能說這個「<strong>手動 import</strong>」做法實在是不得已，因為我們最早介紹<code>pyproject.toml</code>時有提到，<code>poetry add</code>只會在<code>pyproject.toml</code>中寫入「主套件」，但這樣的 import 方式相當於把<code>requirements.txt</code>中的<strong>所有套件，都當作主套件</strong>來<code>add</code>了！</p> \n     <p data-relin-paragraph=\"379\" data-relingo-block=\"true\">畢竟在<code>requirements.txt</code>中<strong>無從區分</strong>主套件與依賴套件，都是「一視同仁」地列出。</p> \n     <p data-relin-paragraph=\"380\" data-relingo-block=\"true\">但如此做法也讓專案的套件<strong>失去主從之分</strong>，這樣會有什麼<strong>壞處</strong>？日後要移除主套件時，<strong>需要花額外的心力去區分主從</strong>（因為僅僅移除依賴套件<strong>並不會有移除效果</strong>），比如使用<code>poetry show --tree</code>去一個一個檢視，終究是件麻煩事。</p> \n     <p data-relin-paragraph=\"381\" data-relingo-block=\"true\">完成轉換後，為保險起見，建議透過新的<code>pyproject.toml</code>來重建一個虛擬環境。</p> \n     <h3 data-relin-paragraph=\"382\" data-relingo-block=\"true\"><span title=\"三、在別台主機上重現專案的 Poetry 虛擬環境\"></span>三、在別台主機上重現專案的 Poetry 虛擬環境</h3> \n     <p data-relin-paragraph=\"383\" data-relingo-block=\"true\">這也是非常常見的需求。</p> \n     <p data-relin-paragraph=\"384\" data-relingo-block=\"true\">第一步當然是<code>git clone</code>專案，此時專案中已經有 Poetry 所需的必要資訊了——也就是<code>pyproject.toml</code>和<code>poetry.lock</code>。</p> \n     <p data-relin-paragraph=\"385\" data-relingo-block=\"true\">你還缺少的僅僅是虛擬環境。如果是全新的主機，則還得先安裝、設定好 Poetry。</p> \n     <p data-relin-paragraph=\"386\" data-relingo-block=\"true\">確定 Poetry 可正常使用後，移至專案目錄底下，依序執行指令：</p> \n     <ol> \n      <li data-relin-paragraph=\"387\" data-relingo-block=\"true\"><code>poetry env use python</code>：建立專案虛擬環境並使用。如果你懶得打這麼長的指令，直接<code>poetry shell</code>也是可以。此時我們會有一個「<strong>空的</strong>」虛擬環境。</li> \n      <li data-relin-paragraph=\"388\" data-relingo-block=\"true\"><code>poetry install</code>：因為是舊專案，不需要<code>init</code>，會直接依<code>poetry.lock</code>記載的套件版本安裝到虛擬環境中！類似<code>npm install</code>。</li> \n     </ol> \n     <h3 data-relin-paragraph=\"389\" data-relingo-block=\"true\"><span title=\"四、我想要移除並重建虛擬環境\"></span>四、我想要移除並重建虛擬環境</h3> \n     <p data-relin-paragraph=\"390\" data-relingo-block=\"true\">在使用「專案內虛擬環境」方案，也就是<code>.venv</code>的前提下，想要刪除這個虛擬環境並加以重建，不能使用<code>poetry env remove python</code>指令，很可能會出錯。</p> \n     <p data-relin-paragraph=\"391\" data-relingo-block=\"true\">不過有更簡單的做法——<strong>直接刪除</strong><code>.venv</code>資料夾即可。</p> \n     <p data-relin-paragraph=\"392\" data-relingo-block=\"true\">然後再<code>poetry env use python</code>或<code>poetry shell</code>建一個新的就好。</p> \n     <h3 data-relin-paragraph=\"393\" data-relingo-block=\"true\"><span title=\"五、為什麼我不在 Docker 環境中使用 Poetry？\"></span>五、為什麼我不在 Docker 環境中使用 Poetry？</h3> \n     <p data-relin-paragraph=\"394\" data-relingo-block=\"true\">因為啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會<strong>增加新的耦合與依賴</strong>，我覺得並不妥當。</p> \n     <blockquote> \n      <p data-relin-paragraph=\"395\" data-relingo-block=\"true\"><code>2023/02/24</code>補充：使用 <a href=\"https://docs.docker.com/build/building/multi-stage/\" rel=\"noopener\" target=\"_blank\">multi-stage builds</a> 的 Dockerfile，可以在第一階段安裝 Poetry，第二階段再把 Poetry 捨棄，這樣就不會有多餘的耦合與依賴了。日後會專文介紹。</p> \n     </blockquote> \n     <p data-relin-paragraph=\"396\" data-relingo-block=\"true\">所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p> \n     <h3 data-relin-paragraph=\"397\" data-relingo-block=\"true\"><span title=\"六、我可以使用自己習慣的 virtualenv 嗎？\"></span>六、我可以使用自己習慣的 virtualenv 嗎？</h3> \n     <p data-relin-paragraph=\"398\" data-relingo-block=\"true\">當然可以。</p> \n     <p data-relin-paragraph=\"399\" data-relingo-block=\"true\">不過我本來也繼續使用<code>pyenv</code>的<code>virtualenv</code>，但兩者有時候也是會小小打架，後來還是索性用 Poetry 的虛擬環境就好。</p> \n     <p data-relin-paragraph=\"400\" data-relingo-block=\"true\">一個專案對應一個虛擬環境，應該還是比較簡潔的做法，我的觀察啦！😎</p> \n     <hr data-relingo-block=\"true\"> \n     <h2 data-relin-paragraph=\"401\" data-relingo-block=\"true\"><span title=\"結語：井然有序的複雜\"></span>結語：井然有序的複雜</h2> \n     <p data-relin-paragraph=\"402\" data-relingo-block=\"true\">總的來說，Poetry 是一款優秀的套件管理工具，但並不像 pip 那般簡單、好上手。</p> \n     <p data-relin-paragraph=\"403\" data-relingo-block=\"true\">使用 Poetry 來管理專案的套件與虛擬環境，需要一定的學習成本，但帶來的效益還是相當可觀的，尤其在你希望能夠乾淨且安心地移除套件之際，可謂莫它莫屬。</p> \n     <p data-relin-paragraph=\"404\" data-relingo-block=\"true\">所以，別再猶豫，從今天起，加入 Poetry 的行列吧！</p> \n     <h3 data-relin-paragraph=\"405\" data-relingo-block=\"true\"><span title=\"參考\"></span>參考</h3> \n     <ul> \n      <li data-relin-paragraph=\"406\" data-relingo-block=\"true\"><a href=\"https://python-poetry.org/docs/\" rel=\"noopener\" target=\"_blank\">https://python-poetry.org/docs/</a></li> \n      <li data-relin-paragraph=\"407\" data-relingo-block=\"true\"><a href=\"https://github.com/python-poetry/poetry\" rel=\"noopener\" target=\"_blank\">https://github.com/python-poetry/poetry</a></li> \n      <li data-relin-paragraph=\"408\" data-relingo-block=\"true\"><a href=\"https://github.com/python-poetry/poetry/issues/3248\" rel=\"noopener\" target=\"_blank\">https://github.com/python-poetry/poetry/issues/3248</a></li> \n      <li data-relin-paragraph=\"409\" data-relingo-block=\"true\"><a href=\"https://github.com/python-poetry/poetry/issues/5185\" rel=\"noopener\" target=\"_blank\">https://github.com/python-poetry/poetry/issues/5185</a></li> \n      <li data-relin-paragraph=\"410\" data-relingo-block=\"true\"><a href=\"https://note.koko.guru/posts/using-poetry-manage-python-package-environments\" rel=\"noopener\" target=\"_blank\">Python - 取代 Pipenv 的新套件管理器 Poetry</a></li> \n      <li data-relin-paragraph=\"411\" data-relingo-block=\"true\"><a href=\"https://greyli.com/poetry-a-better-choice-than-pipenv/\" rel=\"noopener\" target=\"_blank\">相比 Pipenv，Poetry 是一個更好的選擇</a></li> \n      <li data-relin-paragraph=\"412\" data-relingo-block=\"true\"><a href=\"https://shazi.info/pip-pipenv-%E5%92%8C-poetry-%E7%9A%84%E9%81%B8%E6%93%87/\" rel=\"noopener\" target=\"_blank\">pip, pipenv 和 poetry 的選擇</a></li> \n      <li data-relin-paragraph=\"413\" data-relingo-block=\"true\"><a href=\"https://realpython.com/dependency-management-python-poetry/\" rel=\"noopener\" target=\"_blank\">Dependency Management With Python Poetry</a></li> \n      <li data-relin-paragraph=\"414\" data-relingo-block=\"true\"><a href=\"https://pythonhunter.org/episodes/ep15\" rel=\"noopener\" target=\"_blank\">Ep 15. 和 PyPA 的成員聊聊 Python 開發工作流</a></li> \n      <li data-relin-paragraph=\"415\" data-relingo-block=\"true\"><a href=\"https://blog.jihongo.com/posts/2022/06/04/python-poetry/\" rel=\"noopener\" target=\"_blank\">Python - Poetry</a></li> \n     </ul> \n    </div>\n    <p class=\"reader-footer\"><a class=\"reader-footer-source\" href=\"https://cubox.pro/my/card?id=7271464141078924388\" target=\"_blank\"><span class=\"reader-footer-source-label\">跳转到 Cubox 查看</span></a></p>\n   </div>\n  </div>\n  <script type=\"text/javascript\" src=\"https://cubox.pro/article/js/reader.js\"></script>\n </body>\n</html>",
        "status": "success"
      }
    },
    {
      "id": "7271451838447091948",
      "title": "外企非常用词Constitute到底是啥意思_哔哩哔哩_bilibili",
      "data": {
        "content_type": "application/zip;charset=UTF-8",
        "content": "<html id=\"html-top\" lang=\"zh\"><head><meta charset=\"UTF-8\"><title></title><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"><link rel=\"icon\" href=\"https://cubox.pro/my/favicon.svg\" type=\"image/x-icon\"><link href=\"https://cubox.pro/article/css/reader.css\" rel=\"stylesheet\" /></head><body ontouchstart><div class=\"reader-page\">     <div>         <h1 class=\"reader-title\">文章解析</h1>         <div data->很抱歉，没有解析为文章</div>     </div> </div><script type=\"text/javascript\" src=\"https://cubox.pro/article/js/reader.js\"></script></body></html>",
        "status": "success"
      }
    },
    {
      "id": "7271410180867228826",
      "title": "陈天奇团队LLM结构化生成新引擎XGrammar：百倍加速、近零开销",
      "data": {
        "content_type": "application/zip;charset=UTF-8",
        "content": "<html id=\"html-top\" lang=\"zh\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>陈天奇团队LLM结构化生成新引擎XGrammar：百倍加速、近零开销</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n  <link rel=\"icon\" href=\"https://cubox.pro/my/favicon.svg\" type=\"image/x-icon\">\n  <link href=\"https://cubox.pro/article/css/reader.css\" rel=\"stylesheet\">\n </head>\n <body ontouchstart>\n  <div class=\"reader-page\">\n   <div>\n    <h1 class=\"reader-title\">陈天奇团队LLM结构化生成新引擎XGrammar：百倍加速、近零开销</h1>\n    <div class=\"reader-metadata\">\n     <a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650944286&amp;idx=3&amp;sn=c5cf695b7aa64433e8b525a3c292fab4&amp;chksm=85ace354966574f1b72d823ab6bd2c8798fee3b1e951057ab5437d799249a726d3009aa969c5&amp;mpshare=1&amp;scene=1&amp;srcid=1220BCgJFF3ETQ9JtTJpps4I&amp;sharer_shareinfo=bfef5da81df4026206d5c93cb1a18f69&amp;sharer_shareinfo_first=1501e61bf597dd4a3686c59605db1eb6\" target=\"_blank\">mp.weixin.qq.com</a><span class=\"reader-metadata-author\">机器之心</span>\n    </div>\n    <div>\n     <section data-mpa-powered-by=\"yiban.io\" data- data-custom=\"rgb(117, 117, 118)\">\n      <section>\n       <span>机器之心报道</span>\n      </section>\n      <section>\n       <span><strong>编辑：Panda、杜伟<br></strong></span>\n      </section>\n     </section>\n     <blockquote data-source-title=\"\" data-content-utf8-length=\"29\" data-author-name=\"\" data-url=\"\" data-type=\"2\">\n      <section>\n       <span>现在，大语言模型的结构化生成有了一个更加高效、灵活的引擎。</span>\n      </section>\n     </blockquote>\n     <section>\n      <span>不管是编写和调试代码，还是通过函数调用来使用外部工具，又或是控制机器人，都免不了需要 LLM 生成结构化数据，也就是遵循某个特定格式（如 JSON、SQL 等）的数据。</span>\n     </section>\n     <section>\n      <span>但使用上下文无关语法（CFG）来进行约束解码的方法并不高效。针对这个困难，陈天奇团队提出了一种新的解决方案：XGrammar。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibCACEfJficnn2TrDPlzibTvfLvBFr3sE3jP1nIgbmvp4qzbvbe7AMiaqGw/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibCACEfJficnn2TrDPlzibTvfLvBFr3sE3jP1nIgbmvp4qzbvbe7AMiaqGw%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibCACEfJficnn2TrDPlzibTvfLvBFr3sE3jP1nIgbmvp4qzbvbe7AMiaqGw/640?wx_fmt=png&amp;from=appmsg\" data-index=\"1\" data-original- data-w=\"707\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibCACEfJficnn2TrDPlzibTvfLvBFr3sE3jP1nIgbmvp4qzbvbe7AMiaqGw/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.454031117397454\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>XGrammar 是一个开源软件库，可实现高效、灵活且可移植的结构化生成。该团队在博客中表示：「我们毫不妥协地实现了这三个目标，并致力于一个核心使命：将灵活、零开销的结构化生成带到任何地方。」</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibHETtWmAIVI8n43Nkel388oOmLOV14Om8I8GzsmxJhONENpRYS7grBA/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibHETtWmAIVI8n43Nkel388oOmLOV14Om8I8GzsmxJhONENpRYS7grBA%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibHETtWmAIVI8n43Nkel388oOmLOV14Om8I8GzsmxJhONENpRYS7grBA/640?wx_fmt=png&amp;from=appmsg\" data-index=\"2\" data-original- data-w=\"896\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibHETtWmAIVI8n43Nkel388oOmLOV14Om8I8GzsmxJhONENpRYS7grBA/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.21205357142857142\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <ul>\n      <li>\n       <section>\n        <span>论文标题：XGrammar: Flexible and Efficient Structured Generation Engine for Large Language Models</span>\n       </section></li>\n      <li>\n       <section>\n        <span>论文地址：https://arxiv.org/pdf/2411.15100</span>\n       </section></li>\n      <li>\n       <section>\n        <span>代码地址：https://github.com/mlc-ai/xgrammar</span>\n       </section></li>\n     </ul>\n     <section>\n      <span>对于结构化生成，一种常用方法是约束解码。在每个解码步骤中，约束解码都会检查词表，并通过将无效 token 的概率设置为零来过滤掉违反指定结构的 token。为了支持多种多样的结构格式，需要一种灵活的机制来指定和检查这些约束。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibfe6xXNHez8vbD9Rm6H41fr3VRHY1sJr12NFQMAVdsfZhhlMh6BzvYQ/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibfe6xXNHez8vbD9Rm6H41fr3VRHY1sJr12NFQMAVdsfZhhlMh6BzvYQ%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibfe6xXNHez8vbD9Rm6H41fr3VRHY1sJr12NFQMAVdsfZhhlMh6BzvYQ/640?wx_fmt=png&amp;from=appmsg\" data-index=\"3\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibfe6xXNHez8vbD9Rm6H41fr3VRHY1sJr12NFQMAVdsfZhhlMh6BzvYQ/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.49074074074074076\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span><em><span>使用 JSON 方案实现约束解码</span></em></span>\n     </section>\n     <section>\n      <span>上下文无关语法（CFG）就能提供一种通用方法，即通过一组规则来定义结构。其中每条规则都包含一个字符序列或其他规则，并允许递归组合来表示复杂的结构。相比于正则表达式等其它格式，CFG 由于支持递归结构，因而能提供更大的灵活性，使其适合描述 JSON、SQL 和领域特定语言（DSL）等常见语言。</span>\n     </section>\n     <section>\n      <span>下图展示了一个用于数组和字符串的 CFG，可以清楚地看到其中的递归结构。</span>\n     </section>\n     <section>\n      <img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibNJRfJpCE7ibIsjLbwia0VBMC4hkstk9sIYpt41micoBcA6TvQ3bXfsvOg/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibNJRfJpCE7ibIsjLbwia0VBMC4hkstk9sIYpt41micoBcA6TvQ3bXfsvOg%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibNJRfJpCE7ibIsjLbwia0VBMC4hkstk9sIYpt41micoBcA6TvQ3bXfsvOg/640?wx_fmt=png&amp;from=appmsg\" data-index=\"4\" data-original- data-w=\"739\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibNJRfJpCE7ibIsjLbwia0VBMC4hkstk9sIYpt41micoBcA6TvQ3bXfsvOg/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.3220568335588634\" data-imgfile loading=\"lazy\">\n     </section>\n     <section>\n      <span>但是，也正因为 CFG 很灵活，所以直接将其应用于约束解码的效率并不高。首先，每个解码步骤都需要对词表中每个可能的 token 解释 CFG，在 Llama 3.1 中，这个词表的大小可能高达 128k。此外，CFG 解释需要一个堆栈状态来跟踪之前匹配的递归规则，因此无法提前计算和缓存堆栈模式的所有组合。最后，LLM 生成结果中的每个 token 都包含多个字符，这些字符可能会跨越语法元素的边界，并在运行时执行期间导致进一步的递归或堆栈弹出。这种未对齐的边界问题很棘手，需要在语法执行期间小心处理它们。</span>\n     </section>\n     <section>\n      <span>XGrammar 便是为解决上述难题而生的，并且效果卓越：相比于之前的 SOTA 方法，XGrammar 可以将上下文无关语法的每 token 延迟减少多达 100 倍！此外，他们还基于 Llama3.1 模型实验了集成了 XGrammar 的 LLM serving 引擎；在 H100 GPU 上，这能将通过结构化输出实现端到端 LLM serving 的速度提升 80 倍！</span>\n     </section>\n     <section>\n      <span>该团队表示：「我们正在开源 XGrammar 并将其集成到主要的开源 LLM 框架中。」</span>\n     </section>\n     <section>\n      <strong><span>XGrammar 概览</span></strong>\n     </section>\n     <section>\n      <span>如图 1 所示，Grammar 利用了字节级下推自动机（byte-level pushdown automaton）来解释上下文无关语法。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibRO8ySsnhW1mrqHvuB2akHpQicfvhwj1PZVN76ZYf7iaMSkicplZp4nEhg/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibRO8ySsnhW1mrqHvuB2akHpQicfvhwj1PZVN76ZYf7iaMSkicplZp4nEhg%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibRO8ySsnhW1mrqHvuB2akHpQicfvhwj1PZVN76ZYf7iaMSkicplZp4nEhg/640?wx_fmt=png&amp;from=appmsg\" data-index=\"5\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibRO8ySsnhW1mrqHvuB2akHpQicfvhwj1PZVN76ZYf7iaMSkicplZp4nEhg/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.6888888888888889\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>这种字节级设计允许每个字符边缘包含一个或多个字节，处理不规则的 token 边界并支持包含 sub-UTF8 字符的 token 。该自动机的结构经过优化以加快匹配速度。</span>\n     </section>\n     <section>\n      <span>在预处理阶段，会生成一个自适应 token 掩码缓存，它会通过预先计算与上下文无关的 token 来加快运行时的掩码生成。上下文扩展（context extension）能进一步提升这种缓存的有效性。</span>\n     </section>\n     <section>\n      <span>在运行时，token 掩码缓存会快速生成大部分掩码，而持续性执行堆栈会高效处理其余的上下文相关 token。</span>\n     </section>\n     <section>\n      <span>此外，掩码生成和 LLM 推理是互相重叠的，以最大限度地减少约束解码的开销。一旦 LLM 在掩码约束下生成新 token，就会使用此 token 来更新下推自动机的堆栈状态，以进行下一次掩码生成。</span>\n     </section>\n     <section>\n      <span>具体来说，陈天奇团队首先得到了一个见解：虽然无法预先计算下推自动机（PDA）无限多个状态的完整掩码，但可以预先计算掩码中相当一部分（通常超过 99%）的 token。因此，可将这些 token 分成两类：</span>\n     </section>\n     <ul>\n      <li><p><span>上下文无关 token：仅通过查看 PDA 中的当前位置而不是堆栈即可确定其有效性的 token。</span></p></li>\n      <li><p><span>上下文相关 token：必须使用整个堆栈来确定其有效性的 token。</span></p></li>\n     </ul>\n     <section>\n      <span>下图展示了一组上下文相关和无关 token 的示例。大多数情况下，上下文无关 token 占大多数。我们可以预先计算 PDA 中每个位置的上下文无关 token 的有效性，并将它们存储在自适应 token 掩码缓存中。此过程称为语法编译（grammar compilation）。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibmLrZsKKBakczialQY1icYNsDkRuVfurRMLkoU7HlEJSTnpCnUROv8VkA/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibmLrZsKKBakczialQY1icYNsDkRuVfurRMLkoU7HlEJSTnpCnUROv8VkA%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibmLrZsKKBakczialQY1icYNsDkRuVfurRMLkoU7HlEJSTnpCnUROv8VkA/640?wx_fmt=png&amp;from=appmsg\" data-index=\"6\" data-original- data-w=\"1048\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibmLrZsKKBakczialQY1icYNsDkRuVfurRMLkoU7HlEJSTnpCnUROv8VkA/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.8043893129770993\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>下图则展示了自适应存储格式。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib0UtptiaVRyJU9ibQRiaWXoZVibouiaG0RzCOwJHCibmDa1R5R0HibHia05ibeXQ/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuib0UtptiaVRyJU9ibQRiaWXoZVibouiaG0RzCOwJHCibmDa1R5R0HibHia05ibeXQ%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib0UtptiaVRyJU9ibQRiaWXoZVibouiaG0RzCOwJHCibmDa1R5R0HibHia05ibeXQ/640?wx_fmt=png&amp;from=appmsg\" data-index=\"7\" data-original- data-w=\"735\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib0UtptiaVRyJU9ibQRiaWXoZVibouiaG0RzCOwJHCibmDa1R5R0HibHia05ibeXQ/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.9727891156462585\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>在运行时，首先检索来自缓存的上下文无关 token 的有效性。然后，高效地执行 PDA 来检查其余的上下文相关 token。通过跳过运行时检查大多数 token，便可以显著加快掩码生成速度。XGrammar 执行时间的整体工作流程见图 1。</span>\n     </section>\n     <section>\n      <span>此外，他们还设计了一组额外的算法和系统优化方法，以进一步提高掩码生成速度并减少预处理时间，包括上下文扩展、持续性执行椎栈、下推自动机结构优化、并行式语法编译。</span>\n     </section>\n     <section>\n      <strong><span>上下文扩展</span></strong>\n     </section>\n     <section>\n      <span>该团队提出的方法是检测语法中每个规则的额外上下文信息，并将其用于减少上下文相关 token 的数量，并进一步加快运行时检查速度。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibpXJEzPu4kic9K9QxpicATuNibKmS27hSiaIOQ0qGuufncia3aTSUjwMGopg/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibpXJEzPu4kic9K9QxpicATuNibKmS27hSiaIOQ0qGuufncia3aTSUjwMGopg%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibpXJEzPu4kic9K9QxpicATuNibKmS27hSiaIOQ0qGuufncia3aTSUjwMGopg/640?wx_fmt=png&amp;from=appmsg\" data-index=\"8\" data-original- data-w=\"744\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibpXJEzPu4kic9K9QxpicATuNibKmS27hSiaIOQ0qGuufncia3aTSUjwMGopg/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.293010752688172\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <strong><span>持续性执行堆栈</span></strong>\n     </section>\n     <section>\n      <span>为了加快由于多种可能的扩展路径而导致的拆分和合并期间多个并行堆栈的维护速度，他们设计了一个基于树的数据结构，可以有效地同时管理多个堆栈。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib1aICzIdJSWyFm44l2adMibEtCLc6TbpfJUichstibS7ZM0Dxib3ZsGMQ5w/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuib1aICzIdJSWyFm44l2adMibEtCLc6TbpfJUichstibS7ZM0Dxib3ZsGMQ5w%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib1aICzIdJSWyFm44l2adMibEtCLc6TbpfJUichstibS7ZM0Dxib3ZsGMQ5w/640?wx_fmt=png&amp;from=appmsg\" data-index=\"9\" data-original- data-w=\"737\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuib1aICzIdJSWyFm44l2adMibEtCLc6TbpfJUichstibS7ZM0Dxib3ZsGMQ5w/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.1886024423337855\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>它还可以存储以前的状态并实现高效的状态回滚，从而加快上下文相关 token 的运行时检查速度。</span>\n     </section>\n     <section>\n      <strong><span>下推自动机结构优化</span></strong>\n     </section>\n     <section>\n      <span>研究者进行了额外的优化，以改进下推自动机的结构，加快最终执行的效率。这些优化借鉴了传统的编译器优化概念，它们对于高效约束解码特别有用。</span>\n     </section>\n     <section>\n      <span>一是规则内联。在指定的上下文无关语法中，可能有许多片段规则，即只有少数元素的规则，然后在下推自动机中将其转换为小的 FSA（有限状态自动机）。</span>\n     </section>\n     <section>\n      <span>为了解决这个问题，研究者为片段规则引入了一种自动内联策略。他们迭代地选择不引用其他规则的规则并将它们内联到父规则中。为了避免自动机大小的爆炸式增长，研究者将内联规则和内联结果的大小限制为常量。该内联过程几乎消除了片段规则，从而提高了 token 检查的效率并增强了上下文扩展的有效性。</span>\n     </section>\n     <section>\n      <span>二是下推自动机节点合并。对于下推自动机，在许多情况下，歧义来自具有相同标签的节点的多个外向边。在匹配 token 时，如果到达此节点，并且下一个字符恰好与标签匹配，则匹配堆栈将被拆分为多个堆栈，每个外向边一个。堆栈数量增多会增加计算量，这是因为需要检查每个堆栈的上下文相关 token 并合并 token 掩码。</span>\n     </section>\n     <section>\n      <span>为了减少这种歧义，节点合并算法会合并满足以下两个条件的后续节点，a）它们由来自同一点的具有相同标签的边指向，b）它们没有被其他边指向。</span>\n     </section>\n     <section>\n      <span>以上两种优化保留了自动机的等效性，但减少了节点和边的数量。运行时，减少了堆栈的数量和 token 检查所需的计算量，从而加快了掩码的生成过程。</span>\n     </section>\n     <section>\n      <strong><span>重叠掩码生成和 LLM 推理</span></strong>\n     </section>\n     <section>\n      <span>通过上述优化，token 掩码生成过程显著加快，但仍需要 CPU 计算。为了进一步消除约束解码的开销，研究者将 mask 生成计算与 LLM 推理过程重叠，如下图 8 所示。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibPdvt9DXSJjHqHDTbtjubl9V88GljtKic0fnjGfD08f7OpbiaQD2QekMA/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibPdvt9DXSJjHqHDTbtjubl9V88GljtKic0fnjGfD08f7OpbiaQD2QekMA%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibPdvt9DXSJjHqHDTbtjubl9V88GljtKic0fnjGfD08f7OpbiaQD2QekMA/640?wx_fmt=png&amp;from=appmsg\" data-index=\"10\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibPdvt9DXSJjHqHDTbtjubl9V88GljtKic0fnjGfD08f7OpbiaQD2QekMA/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.47129629629629627\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>研究者观察到，mask 生成过程和 LLM 推理过程可以重叠，原因在于 mask 生成只需要 CPU，并且只依赖于之前生成的 token。LLM 推理过程（除采样阶段外）只需要 GPU，并且也只依赖于之前生成的 token。因此可以将 CPU 上的 mask 生成过程与 GPU 上的 LLM 推理过程并行化。</span>\n     </section>\n     <section>\n      <strong><span>评估结果</span></strong>\n     </section>\n     <section>\n      <span>研究者利用 12,000 行核心 C++ 代码来实现 XGrammar，并提供了 Python 捆绑包以方便与 LLM 推理框架无缝集成。他们在评估 XGrammar 过程中回答以下几个问题：</span>\n     </section>\n     <ul>\n      <li><p><span>XGrammar 能否高效支持约束解码的每个步骤？</span></p></li>\n      <li><p><span>XGrammar 能否在 LLM serving 中实现端到端结构化生成的最小开销？</span></p></li>\n      <li><p><span>XGrammar 能否部署在更广泛的平台上？</span></p></li>\n     </ul>\n     <section>\n      <strong><span>语法引擎效率</span></strong>\n     </section>\n     <section>\n      <span>本节中评估了语法引擎的性能。研究者在 Llama-3.1-8B Instruct 上评估了他们的方法和基线，该模型能够遵循人类的指令。</span>\n     </section>\n     <section>\n      <span>结果如下图 9 所示，在 JSON 模式设置中，XGrammar 可以实现高达 3 倍的加速；在 JSON 语法用例下，可以实现超过 100 倍的加速。与 JSON 模式（更受限制）相比，JSON 的上下文无关语法包含更复杂的规则，因为它可以包含递归列表和字典，导致语法引擎更难有效地执行它。</span>\n     </section>\n     <section>\n      <span>在这两种情况下，XGrammar 都可以在不到 40 微秒的时间内生成每个 token 的掩码，使其成为低延迟 LLM 推理的理想选择。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibOnzqzYZlUqjQDuic6CfiadfB1z7bq3vSrWePL8l17KKZbJUCJ2M5NwXw/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibOnzqzYZlUqjQDuic6CfiadfB1z7bq3vSrWePL8l17KKZbJUCJ2M5NwXw%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibOnzqzYZlUqjQDuic6CfiadfB1z7bq3vSrWePL8l17KKZbJUCJ2M5NwXw/640?wx_fmt=png&amp;from=appmsg\" data-index=\"11\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibOnzqzYZlUqjQDuic6CfiadfB1z7bq3vSrWePL8l17KKZbJUCJ2M5NwXw/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.450925925925926\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <strong><span>端到端 LLM 引擎评估</span></strong>\n     </section>\n     <section>\n      <span>本节在 LLM serving 设置下来评估 XGrammar。研究者将 XGrammar 集成到端到端 LLM 推理框架中，并与其他 LLM serving 框架进行效率比较。同时，他们还与其他支持结构化生成的 LLM 引擎进行效率比较，包括集成 Outlines 的 vLLM (v0.6.3) 和内置语法引擎的 llama.cpp。</span>\n     </section>\n     <section>\n      <span>实验结果如下图 10 所示，XGrammar 在 CFG 和 JSON 模式的所有基线中实现了最佳的 TTFT 和 TPOT。vLLM 和 llama.cpp 的计算受到其语法引擎更长预处理和每个 token 处理时长的阻碍。</span>\n     </section>\n     <section>\n      <span>在批量较大的情况下，vLLM 中 TPOT 速度的下降尤为明显。与现有解决方案相比，XGrammar 引擎总体上可以将输出 token 的速度提高 80 倍。这种加速来自 XGrammar 带来的性能优化。</span>\n     </section>\n     <section>\n      <img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibevNxzmY4Xy7S2zQZ1fgm0gMZgmfTgmIT2eR5qy2g2eTe6lOWXL0hcw/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibevNxzmY4Xy7S2zQZ1fgm0gMZgmfTgmIT2eR5qy2g2eTe6lOWXL0hcw%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibevNxzmY4Xy7S2zQZ1fgm0gMZgmfTgmIT2eR5qy2g2eTe6lOWXL0hcw/640?wx_fmt=png&amp;from=appmsg\" data-index=\"12\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibevNxzmY4Xy7S2zQZ1fgm0gMZgmfTgmIT2eR5qy2g2eTe6lOWXL0hcw/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.6731481481481482\" data-imgfile loading=\"lazy\">\n     </section>\n     <section>\n      <span>研究者还在下表 1 中研究了语法处理的开销问题。由于 token 掩码生成效率和语法 GPU 重叠，语法过程在 TPOT 中几乎不产生任何开销。</span>\n     </section>\n     <section>\n      <img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibqDgeVusibIkTBruj0icKiaaPjWcN8jB3GQZicFTmMxSjQpYIjaeawNBOVw/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibqDgeVusibIkTBruj0icKiaaPjWcN8jB3GQZicFTmMxSjQpYIjaeawNBOVw%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibqDgeVusibIkTBruj0icKiaaPjWcN8jB3GQZicFTmMxSjQpYIjaeawNBOVw/640?wx_fmt=png&amp;from=appmsg\" data-index=\"13\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibqDgeVusibIkTBruj0icKiaaPjWcN8jB3GQZicFTmMxSjQpYIjaeawNBOVw/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"0.40555555555555556\" data-imgfile loading=\"lazy\">\n     </section>\n     <section>\n      <span></span>\n     </section>\n     <section>\n      <span></span>\n     </section>\n     <section>\n      <strong><span>跨平台部署</span></strong>\n     </section>\n     <section>\n      <span>本节探讨如何将 XGrammar 引入各种平台。研究者利用 Emscripten 将 XGrammar 编译成 WebAssembly 并构建 JavaScript 捆绑包。他们进一步将 web-binding 与浏览器内 LLM 推理框架 WebLLM 集成，以实现结构化生成。</span>\n     </section>\n     <section>\n      <span>研究者使用 JSON-mode-eval 数据集评估端到端性能，在装有 Google Chrome 的 MacBook Pro M3 Max（macOS 14.5）上使用 4 位量化模型 Llama-3.1-8B-Instruct，并在装有 Safari 的 iPhone 14 Pro Max（iOS 18）上使用 Qwen2.5-0.5B-Instruct。</span>\n     </section>\n     <section>\n      <span>结果如下图 11 所示，研究者比较了使用 XGrammar 进行结构化生成和非结构化生成时的第一个 token 时间 (TTFT) 和每个输出 token 时间 (TPOT)，同时确保生成的 token 数量相同。结果表明，XGrammar 在两种设置下都几乎实现了零开销，在支持未来高性能端侧智能体方面具有巨大潜力。</span>\n     </section>\n     <section>\n      <span><img data-cubox-image-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibhDSEpzNSttbjBHnSxSRuI17gQxdxic4AZPkUnpj7tw1EiaZiad4Boq8Vg/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-fail=\"0\" crossorigin=\"anonymous\" src=\"https://cubox.pro/c/filters:no_upscale()?imageUrl=https%3A%2F%2Fmmbiz.qpic.cn%2Fsz_mmbiz_png%2FKmXPKA19gWibricw4ugoO0qq7LXptbIEuibhDSEpzNSttbjBHnSxSRuI17gQxdxic4AZPkUnpj7tw1EiaZiad4Boq8Vg%2F640%3Fwx_fmt%3Dpng%26from%3Dappmsg\" data-cubox-archive-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibhDSEpzNSttbjBHnSxSRuI17gQxdxic4AZPkUnpj7tw1EiaZiad4Boq8Vg/640?wx_fmt=png&amp;from=appmsg\" data-index=\"14\" data-original- data-w=\"1080\" data-type=\"png\" data-src=\"https://mmbiz.qpic.cn/sz_mmbiz_png/KmXPKA19gWibricw4ugoO0qq7LXptbIEuibhDSEpzNSttbjBHnSxSRuI17gQxdxic4AZPkUnpj7tw1EiaZiad4Boq8Vg/640?wx_fmt=png&amp;from=appmsg\" data-ratio=\"1.0305555555555554\" data-imgfile loading=\"lazy\"></span>\n     </section>\n     <section>\n      <span>更多技术细节请参阅原论文。</span>\n     </section>\n     <section>\n      <span>© THE END </span>\n     </section>\n     <section>\n      <span>转载请联系本公众号获得授权</span>\n     </section>\n     <section>\n      <span>投稿或寻求报道：liyazhou@jiqizhixin.com</span>\n     </section>\n    </div>\n    <p class=\"reader-footer\"><a class=\"reader-footer-source\" href=\"https://cubox.pro/my/card?id=7271410180867228826\" target=\"_blank\"><span class=\"reader-footer-source-label\">跳转到 Cubox 查看</span></a></p>\n   </div>\n  </div>\n  <script type=\"text/javascript\" src=\"https://cubox.pro/article/js/reader.js\"></script>\n </body>\n</html>",
        "status": "success"
      }
    }
  ]
}